---
title: "01_HDCA_heart_QC_and_high_level_analysis"
author: "Julia Foyer, Ludvig Larsson & RaphaÃ«l Mauron"
output: html_document
editor_options: 
  chunk_output_type: console
---

# HDCA heart QC and high level analysis

Here begins the analysis of the single-cell embryonic heart development. The script consists of the initial processing of the data, followed by filtering and analysis of the main High-Level clusters. Subsequently, numerous complementary analyses are conducted on the data generated by this script.

## Settings

### Set library path

```{r setup, include=FALSE}
.libPaths("/home/rstudio/project/renv/library/R-4.3/aarch64-unknown-linux-gnu/")
knitr::opts_chunk$set(echo = TRUE)
```


### Set environment variables

```{r}
# Set the directory 
myfolder <- "/home/rstudio/project/output/HDCA_heart_sc_analysis_docker/"
PATH_DATA <- "/home/rstudio/project/data/h5_files/"
file_list <- list.files(PATH_DATA, full.names = FALSE, pattern = ".h5")
```


### Load Libraries

```{r, message = FALSE}
library(Seurat)
library(Matrix)
library(future)
library(RcppHNSW)
library(igraph)
library(future.apply)
library(niceRplots)
library(DoubletFinder)
library(ggplot2)
library(ROCR)
library(KernSmooth)
library(dplyr)
library(patchwork)
library(harmony)
library(gprofiler2)
library(plotly)
```


### Load global functions

```{r}
source("/home/rstudio/project/code/global_functions.R")
```


### Set seed

```{r}
set.seed(1)
```


## Read files

### Create Seurat object from .h5 files

```{r}
plan(multicore, workers=7 )

# load the matrix, create a Seurat object and store it in a list for all datasets in parallel
data_list <- future_lapply( 
  file_list ,function(x) { 
    data <- Matrix::Matrix(rhdf5::h5read(paste0(PATH_DATA,x), name = "/shoji/Expression"), sparse = TRUE)
    colnames(data) <-  rhdf5::h5read(paste0(PATH_DATA,x), name = "/shoji/Cellid")
    rownames(data) <-  rhdf5::h5read(paste0(PATH_DATA,x), name = "/shoji/Gene")
    data <- CreateSeuratObject(counts = data)
    data$sampleID <- gsub(".h5", "", x)
    return(data)
    } ,future.seed = 1)

names(data_list) <- file_list
gc()
```


### Merge datasets

```{r}
plan(multicore, workers=7)

data <- merge(data_list[[1]], data_list[-1])
rm(data_list)
gc()
```


### Import metadata from loom files and metadata file

```{r}
temp <- future_lapply( 
  file_list ,function(x) { 
    temp <- rhdf5::h5read(paste0(PATH_DATA,x),name = "/shoji/DoubletFlag")
    temp2 <-  rhdf5::h5read(paste0(PATH_DATA,x),name = "/shoji/DoubletScore")
    temp3 <-  rhdf5::h5read(paste0(PATH_DATA,x),name = "/shoji/DropletClass")
    temp4 <- cbind(DoubletFlag = temp, DoubletScore = temp2, DropletClass = temp3)
    rownames(temp4) <-  rhdf5::h5read(paste0(PATH_DATA,x),name = "/shoji/Cellid")
    return(temp4)
    } ,future.seed = 1 )

# Apply the function rbind to all elements of the list temp to combine them by row.
temp <- do.call(rbind, temp)
# Add the temp dataframe to the Seurat metadata. Column bind (put the columns side by side)
data@meta.data <- cbind(data@meta.data, temp)

metadata <- read.delim("/home/rstudio/project/data/metadata/Result_1_210211_121011.tab",row.names = 2)
identities <- as.character(sub("Ten", 10, file_list))
metadata <- metadata[as.character(sub(".h5","",identities)),]
metadata$age
data@meta.data$age <- metadata[match(sub(":.*", "",colnames(data)), rownames(metadata)), "age"]

gc()
rm(file_list)
```


### Round ages to create age groups

```{r}
# Factor automatically adds Levels based on alphabetical order.
data$age_round_up <- factor(sprintf("%02d",ceiling(data$age)))
data$age_round_down <- factor(sprintf("%02d",floor(data$age)))
```


## QC

### Normalize data

```{r}
plan(sequential)
data <- NormalizeData(data)
gc()
```


### QC calculation

* Calculate percentage of ribosomal protein coding genes ^RP[LS]
* Calculate percentage of mitochondrial protein coding genes ^MT-
* Calculate percentage of hemoglobin genes ^HB[^ESP]|HBE1
* Calculate percentage of heat shock protein coding genes ^HSP

```{r}
plan(multicore, workers = 7)
data <- PercentageFeatureSet(data,pattern = "^RP[LS]", col.name = "percent_ribo")
data <- PercentageFeatureSet(data,pattern = "^MT-", col.name = "percent_mito")
data <- PercentageFeatureSet(data,pattern = "^HB[^ESP]|HBE1", col.name = "percent_hb")
data <- PercentageFeatureSet(data,pattern = "^HSP", col.name = "percent_hsp")
# Add a flag for potentially apoptotic cells
data$apoptotic_maybe <- data$percent_hsp > 2
gc()
```


### Cell cycle score calculation

Use `CellCycleScoring` from Seurat to estimate scores for G1, G2M and S phases.

```{r}
plan(sequential)

# For the results, never trust the "phase".
data <- CellCycleScoring(data, 
                          s.features = cc.genes.updated.2019$s.genes,
                          g2m.features = cc.genes.updated.2019$g2m.genes)
gc()
```


### Find Variable Features

```{r}
plan(sequential)
data <- FindVariableFeatures(data, nfeatures = 4000)
gc()
```


### Scale Data

Fits a linear regression for every gene against confounding variables to compute the residuals (corrected values), which are then centered (mean = 0) and scaled (STD = 1). The resulting matrix will be FULL and not sparse. This takes a lot of memory and can be deleted after computing PCA.

```{r}
plan(sequential)
data <- ScaleData(data)
gc()
```


### PCA

This is a stochastic (rather than deterministic) algorithm for calculating PCA. This function uses the irlba package, which makes it stochastic. For stochastic you can predifine how many PCs you want to compute, but for the deterministic approach (package prcomp) the minimal number of PCs will be the number of rows or columns of the original matrix (depending on which one is smaller), e.g. 3000 variable genes.

```{r}
plan(sequential)
data <- RunPCA(data, npcs = 50, verbose = TRUE, seed.use = 42)
gc()
```


### UMAP

```{r}
data <- RunUMAP(data, 
                dims = 1:50, 
                reduction = "pca",
                n.neighbors = 10,
                n.epochs = 200,
                reduction.key = "unfilt",
                reduction.name = "umap_unfilt",
                seed.use = 42)
gc()
```


### Graph construction

Use the `RcppHNSW` R package to create a nearest neighbor (nn) adjacency matrix.

```{r}
set.seed(1)
nn <- CreateNNAdjacencyMatrix(data, reduction = "pca", dims = 1:50, k = 20)
```


### Clustering

```{r}
# Cluster adjacency matrix
cl <- LouvainClustering(nn = nn, resolution = 1)
data$clusters_louvain_unfilt <- factor(cl)

gc()
```


## Export Seurat object unfiltered

Export the Seurat object containing the initial clusters, reduced dimensions, ... before filtering steps. 

```{r}
saveRDS(data, paste0(myfolder, "rds_objects/HDCA_heart_sc_unfiltered.rds"))
```

```{r}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_unfiltered.rds"))
```


## QC infos and Plotting of QC + some metafeatures

```{r}
data
```

#[1]  59480 107673

### Patchword of QC plots from different metrics from metadata

```{r}
features_cat <- c("clusters_louvain_unfilt", "orig.ident", "apoptotic_maybe")
features_num <- c("nCount_RNA", "nFeature_RNA", "percent_ribo", "percent_mito", "percent_hb", "percent_hsp", "S.Score", "G2M.Score", "DoubletFlag", "DoubletScore", "XIST", "age")

png(paste0(myfolder, "QC/01.QC_umap_unfiltered.png"), width = 600*5, height = 600*5, res = 200)
par(mfrow = c(5,5), mar = c(4,4,4,4))
for (i in features_cat){
  plot_meta(data, red = "umap_unfilt", feat = i, label = TRUE)
}
for (i in features_num){
  plot_feat(data, red = "umap_unfilt", feat = i)
}
dev.off()

rm(features_cat, features_num, i, metadata, nn, temp, cl, identities)
gc()
```


### Samples Quality: nCount & nFeature *before filtering*

```{r}
pdf(paste0(myfolder, "p_nFeature_RNA_before_filter.pdf"), width = 15, height = 15)
VlnPlot(data, features = "nFeature_RNA")
dev.off()

pdf(paste0(myfolder, "p_nCount_RNA_before_filter.pdf"), width = 15, height = 15)
VlnPlot(data, features = "nCount_RNA")
dev.off()
```


## Filtering

### Select cells to filter prior to running doublet finder

* Remove cells with a percentage of mitochondrial gene counts above 30%
* Remove cells with a percentage of ribosomal protein coding gene counts below 3% and a percentage of hemoglobin gene counts below 10% 
* Remove cells with less than 250 unique genes detected and a percentage of hemoglobin gene counts below 10% 

```{r, results='hide'}
cells_to_filter_out1 <- data@meta.data$percent_mito > 30
cells_to_filter_out2 <- data@meta.data$percent_ribo < 3 & data@meta.data$percent_hb < 10
cells_to_filter_out3 <- data@meta.data$nFeature_RNA < 250 & data@meta.data$percent_hb < 10
to_filter <- cells_to_filter_out1 | cells_to_filter_out2 | cells_to_filter_out3

rm(cells_to_filter_out1, cells_to_filter_out2, cells_to_filter_out3)
gc()
```


### Visualize the filtering

```{r}
plan(multicore, workers = 7)

QC_03_plot(data = data, 
           filename = paste0(myfolder, "QC/03.Quality_metrics_filtering.png"), 
           to_filter = to_filter)

features_cat <- c("seurat_clusters", "orig.ident", "clusters_louvain_unfilt", 
                  "scpred_prediction", "apoptotic_maybe")
features_num <- c("nCount_RNA", "nFeature_RNA", "percent_ribo", "percent_mito", 
                  "percent_hsp", "percent_hb", "S.Score", "G2M.Score", "DoubletFlag", "DoubletScore")

rm(features_cat, features_num)
gc()
```


### Filter cells

Remove all cells fulfilling filter criteria.

```{r}
data <- data[, !to_filter]
```


### Doublet Finding

`FindDoublets` runs a doublet detection workflow for each dataset (sampleID) separately. The results are then merged to create a new Seurat object.

```{r}
data_list <- FindDoublets(data = data, myfolder = myfolder)
```


## Export Seurat objects (data_list) after doublets are detected

```{r}
saveRDS(data_list, paste0(myfolder, "rds_objects/HDCA_heart_sc_doubletfound.rds"))
```

```{r}
data_list <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_doubletfound.rds"))
```


## Merge data_list into data

```{r}
gc()
plan(sequential)
data <- merge(data_list[[1]], data_list[-1])
rm(data_list)
gc()
```


### Rerun normalization, variable feature detection, scaling, PCA, UMAP on the new formed/merged Seurat object

```{r}
set.seed(1)
gc()
plan(sequential)

data <- data %>%
  NormalizeData() %>%
  FindVariableFeatures(nfeatures = 4000)
gc()


data <- data %>%
  ScaleData() 
gc()


data <- data %>%
  RunPCA(npcs = 50, seed.use = 42) %>%
  RunUMAP(dims = 1:50, n.neighbors = 10, n.epochs = 200,
          n.threads = 7, reduction.key = "unfilt", reduction.name = "umap_df", seed.use = 42)

set.seed(1)
# Convert doublet classes to factor
data$DF.classifications <- factor(data$DF.classifications, levels = c("Singlet", "Doublet"))
gc()
```


## Export Seurat object (data) with doublet scores added to the object

```{r}
saveRDS(data, paste0(myfolder, "rds_objects/HDCA_heart_sc_doubletfound02.rds"))
```

```{r}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_doubletfound02.rds"))
```

# [1]  59480 101104

## Samples Quality: nCount & nFeature *after filtering and doublet found*

```{r}
#Violin plot
pdf(paste0(myfolder, "p_nFeature_RNA_after_filter.pdf"), width = 15, height = 15)
VlnPlot(data, features = "nFeature_RNA")
dev.off()

pdf(paste0(myfolder, "p_nCount_RNA_after_filter.pdf"), width = 15, height = 15)
VlnPlot(data, features = "nCount_RNA")
dev.off()
```


### Plot results from doublet detection workflow

```{r}
# Plot results
p1 <- DimPlot(data, group.by = "sampleID", reduction = "umap_df",
              raster = FALSE, order = TRUE) + NoAxes()
p2 <- DimPlot(data, group.by = "DF.classifications", reduction = "umap_df",
              raster = FALSE, order = TRUE) + NoAxes()

# Export plot
png(filename = paste0(myfolder, "QC/Doublet_Finding/DoubletFinder.png"), 
    width = 4500, height = 2500, res = 300)
p1 | p2
dev.off()
gc()
```


### Compare doublet finding results

1. Plot Doublet Score on umap
2. Plot probability of annotations on umap
3. Plot Doublet Flag on umap
4. Plot Doublet Finder classifications on umap

```{r}
p1 <- FeaturePlot(data, reduction = "umap_df", features = "DoubletScore", raster = FALSE)
p2 <- FeaturePlot(data, reduction = "umap_df", features = "pANN", raster = FALSE)
p3 <- DimPlot(data, reduction = "umap_df", group.by = "DoubletFlag", raster = FALSE)
p4 <- DimPlot(data, reduction = "umap_df", group.by = "DF.classifications", raster = FALSE)

# Export plots
png(paste0(myfolder, "QC/Doublet_Finding/Doublet_option_1.png"), 
    width = 2400*4, height = 2400*2, res = 300)
p1 | p3
dev.off()

png(paste0(myfolder, "QC/Doublet_Finding/Doublet_option_2.png"), 
    width = 2400*4, height = 2400*2, res = 300)
p2 | p4
dev.off()
```

```{r}
#remove plots from environment to free space
rm(p1, p2, p3, p4)
```


## Second filtering (RBC & doublets)

* Remove erythrocytes (RBCs) based on percentage of hemoglobin counts. These were not removed in the previous filter because they were used for the doublet detection. 
* Remove detected doublets.

```{r}
cells_to_filter_out1 <- data@meta.data$percent_hb > 10
cells_to_filter_out2 <- data@meta.data$DF.classifications == "Doublet"
to_filter <- cells_to_filter_out1 | cells_to_filter_out2
rm(cells_to_filter_out1, cells_to_filter_out2)
```


### Visualize the second filtering

```{r}
QC_03_plot(data = data, 
           filename = paste0(myfolder, "QC/03.Quality_metrics_filtering_2nd.png"), 
           to_filter = to_filter)

features_cat <- c("seurat_clusters", "orig.ident", "clusters_louvain_unfilt", "scpred_prediction", "apoptotic_maybe")
features_num <- c("nCount_RNA", "nFeature_RNA", "percent_ribo", "percent_mito", "percent_hsp", "percent_hb", "DF.classification", "pANN")

rm(features_cat, features_num)
gc()
```


### Filter cells based on second filter criteria.

```{r}
data <- data[, !to_filter]
gc()
rm(to_filter)
```


## Dimensionality reduction

### Find variable genes

```{r}
set.seed(1)
plan(sequential)
data <- FindVariableFeatures(data, nfeatures = 4000)
gc()
```


## Export Seurat object after the 2 filtering steps

```{r, eval=FALSE}
saveRDS(object = data, 
        file = paste0(myfolder, "rds_objects/HDCA_heart_sc_scaledata_prefiltered_adjusted0.rds"))
```

```{r, include=FALSE}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_scaledata_prefiltered_adjusted0.rds"))
```


### Scale Data

Fits a linear regression for every gene against confounding variables to compute the residuals (corrected values), which are then centered (mean = 0) and scaled (STD = 1). The resulting matrix will be FULL and not sparse. This takes a lot of memory and can be deleted after computing PCA.

```{r}
set.seed(1)
plan(sequential)
data <- ScaleData(data, 
                  vars.to.regress = c("nCount_RNA", "nFeature_RNA", "percent_ribo", 
                                      "percent_mito", "percent_hb", "percent_hsp", 
                                      "S.Score", "G2M.Score"))
gc()
```


## Export Seurat object scaled after filtering steps

```{r, eval=FALSE}
saveRDS(object = data, file = paste0(myfolder, "rds_objects/HDCA_heart_sc_scaledata_prefiltered_adjusted.rds"))
```

```{r, include=FALSE}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_scaledata_prefiltered_adjusted.rds"))
```

# [1] 59480 76991

### PCA

This is a stochastic (rather than deterministic) algorithm for calculating PCA. This function uses the irlba package, which makes it stochastic. For stochastic you can predefine how many PCs you want to compute, but for the deterministic approach (package prcomp) the minimal number of PCs will be the number of rows or columns of the original matrix (depending on which one is smaller), e.g. 3000 variable genes.

```{r}
data <- RunPCA(data, npcs = 50, seed.use = 42)
gc()
```


## Integration

### Integration based on sampleID

Use harmony to integrate data across samples.

```{r}
# Integration based on dataset
set.seed(1)
data <- RunHarmony(data, dims.use = 1:50,
                   group.by.vars = c("sampleID"), 
                   reduction = "pca",
                   project.dim = FALSE,
                   reduction.save = "harmony_oi")
gc()
```


### UMAP computation

Use harmony reduced dimension of data as input for UMAP.

```{r}
data <- RunUMAP(data, 
                dims = 1:50, 
                reduction = "harmony_oi",
                n.neighbors = 10,
                metric = "cosine",
                n.epochs = 100,
                reduction.key = "oi_",
                reduction.name = "umap_oi",
                seed.use = 42)
```


### Check the result

```{r}
png(paste0(myfolder, "integration_sampleID.png"), width = 3000, height = 3000, res = 300)
DimPlot(data, reduction = "umap_oi", group.by = "sampleID", raster = F)
dev.off()
```


## Clustering

```{r}
set.seed(1)
# Create adjacency matrix from harmony reduced dimension
nn <- CreateNNAdjacencyMatrix(data = data, reduction = "harmony_oi", dims = 1:50, k = 20)

# Cluster adjacency matrix
cl <- LouvainClustering(nn = nn, resolution = 1.8)

# add to metadata
data$clusters_louvain_oi <- factor(cl)

gc()
```

```{r}
rm(nn, cl)
```


### Visualize clusters

```{r}
png(paste0(myfolder, "clusters.png"), width = 2400*3, height = 2400*3, res = 600)
DimPlot(data, reduction = "umap_oi", group.by = "clusters_louvain_oi", label = T, raster = F) + NoLegend() + labs(title = "Clusters Louvain")
dev.off()

pdf(paste0(myfolder, "clusters.pdf"), width = 15, height = 15)
DimPlot(data, reduction = "umap_oi", group.by = "clusters_louvain_oi", label = T, raster = F)
dev.off()
```


### Visualize dataset proportions per cluster

```{r}
png(paste0(myfolder, "cluster_dataset_distributions.png"), width = 400*12, height = 400*4, res = 300)
df <- as.data.frame(table(data.frame(clusters = data$clusters_louvain_oi, dataset = data$orig.ident)))
df <- df %>% 
  group_by(dataset) %>% 
  mutate(prop_cluster = Freq/sum(Freq)) %>% 
  group_by(clusters) %>% 
  mutate(prop_dataset = Freq/sum(Freq))

ggplot(df, aes(clusters, prop_dataset, fill = dataset)) +
  geom_bar(stat = "identity") +
  coord_flip()

dev.off()
```


### Visualize composition of clusters per dataset

```{r}
png(paste0(myfolder, "age_dataset_cluster_distributions.png"), width = 800*12, height = 800*4, res = 600)
par(mfrow=c(2,2), mar=c(4,4,4,4))

# Count cells per cluster and dataset
df <- as.data.frame(table(data.frame(clusters = data$clusters_louvain_oi, dataset = data$orig.ident)))
conv <- data@meta.data[, c("orig.ident", "age_round_up")]
conv <- conv[!duplicated(conv), ]
conv <- setNames(conv$age, nm = conv$orig.ident)
df$age <- conv[df$dataset]

df <- df %>% 
  group_by(dataset, age) %>% 
  mutate(prop_cluster = Freq/sum(Freq)) %>%
  mutate(age_dataset = paste0(age, "_", dataset))
df$age_dataset <- factor(df$age_dataset)

ggplot(df, aes(age_dataset, prop_cluster, fill = clusters)) +
  geom_bar(stat = "identity") +
  coord_flip()

dev.off()
rm(df, conv)
```


### Split UMAP

1. Split by age and individual heart
2. Split by age and sample

```{r}
data$age_heart <- paste0(data$age_round_down, "_", data$orig.ident)
data$age_dataset <- paste0(data$age_round_down, "_", data$sampleID)

png(paste0(myfolder, "umap_age_heart.png"), width = 3000, height = 2000, res = 300)
DimPlot(data, reduction = "umap_oi", group.by = "clusters_louvain_oi", split.by = "age_heart", ncol = 5, raster = TRUE) + NoLegend() + labs(title = "Clusters Louvain for each heart")
dev.off()

png(paste0(myfolder, "umap_age_dataset.png"), width = 3000, height = 2000, res = 300)
DimPlot(data, reduction = "umap_oi", group.by = "clusters_louvain_oi", split.by = "age_dataset", ncol = 5, raster = TRUE) + NoLegend() + labs(title = "Clusters Louvain for each dataset")
dev.off()
```


## Calculate differentially expressed genes (DEG) *before annotation*

### Remove mitochondrial and ribosomal protein coding genes

```{r}
data <- data[!grepl("^MT-", rownames(data)), ]
data <- data[!grepl("^RP[LS]", rownames(data)), ]
gc()
```

```{r}
# Select a new samples size for each cluster, to get groups that are equally (or almost equally) large.
sample_size <- table(data$clusters_louvain_oi)
sample_size[sample_size > 150] <- 150
sample_size

# Randomly sample the cells that will be included when calculating DGE (same number of cells as selected above).
# Samples without replacement, so each cell only can be included once.
DGE_cells <- lapply(names(sample_size), function(x){ 
  set.seed(1)
  sample(colnames(data)[data$clusters_louvain_oi == x], size = sample_size[x])
  })
DGE_cells <- unlist(DGE_cells)

# Select all data that relates to the sampled DGE cells.
DGE_DATA <- data[, DGE_cells]

#Find differentially expressed genes based on groups defined by "clusters_louvain_oi".
DGE_DATA <- SetIdent(DGE_DATA, value = "clusters_louvain_oi")

# The logfc threshold is set to 0.1 as compared to the default 0.25, which makes the detection of weaker signals possible (but it takes more computational power).
detable <- FindAllMarkers(DGE_DATA,
                          only.pos = TRUE,
                          max.cells.per.ident = 300,
                          logfc.threshold = .1,
                          assay = "RNA",
                          min.pct = 0.05)

# Only keep DEGs that have a p-value below 0.05.
detable <- detable[detable$p_val < 0.05, ]

# Adding two extra columns giving the difference (and log difference) between pct1 and pct2.
# pct1 is the percentage of cells in the specific cluster that express this gene.
# pct2 is the percentage of cells in all other clusters that express this gene.
detable$pct.diff <- detable$pct.1 - detable$pct.2
detable$log.pct.diff <- log2((detable$pct.1*99+1) / (detable$pct.2*99+1))

# Save the detable as a csv file.
write.csv2(detable, paste0(myfolder, "detable_rough_clusters.csv"))

# Pick the 60 genes with the lowest p value for each age group, then 40 highest based on pct.diff, then 20 highest based on log.pct.diff.
# This gives a total of 140 genes (20 per age group).
detable %>%
  group_by(cluster) %>%
  top_n(-60, p_val) %>%
  top_n(40, pct.diff) %>%
  top_n(20, log.pct.diff) ->
  top20

# Genes get matched to one specific cluster and the factor is leveled based on cluster number.
ord <- factor(sapply(unique(as.character(top20$gene)), function(x){niceRplots::getcluster(DGE_DATA, x, "clusters_louvain_oi")}))

pdf(paste0(myfolder, "DGE_rough_before_ann.pdf"), width = 15, height = 115)
par(mfrow=c(1,1), mar=c(3,6,2,5))
DotPlot(DGE_DATA, features = unique(as.character(top20$gene))[order(as.numeric(as.character(ord)))]) +
  coord_flip() +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete(limits = rev) +
  scale_y_discrete() +
  labs(x = "", y = "") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
dev.off()

rm(detable, DGE_DATA, top20, DGE_cells, ord, sample_size)
```


### DEG clusters 18 and 27 (CM) only

Based on `DGE_rough_before_ann.pdf` clusters 18 and 27 were selected for a in depth analysis of DEG separately.

```{r}
data_18_27 <- data[, data$clusters_louvain_oi == "18" | 
             data$clusters_louvain_oi =="27"]

# Select a new samples size for each cluster, to get groups that are equally (or almost equally) large.
sample_size <- table(data_18_27$clusters_louvain_oi)
sample_size[sample_size > 150] <- 150
sample_size


# Randomly sample the cells that will be included when calculating DGE (same number of cells as selected above).
# Samples without replacement, so each cell only can be included once.
DGE_cells <- lapply(names(sample_size), function(x){ 
  set.seed(1)
  sample(colnames(data_18_27)[data_18_27$clusters_louvain_oi == x], size = sample_size[x])
  })
DGE_cells <- unlist(DGE_cells)

# Select all data that relates to the sampled DGE cells.
DGE_DATA <- data_18_27[, DGE_cells]

#Find differentially expressed genes based on groups defined by "clusters_louvain_oi".
DGE_DATA <- SetIdent(DGE_DATA, value = "clusters_louvain_oi")

# The logfc threshold is set to 0.1 as compared to the default 0.25, which makes the detection of weaker signals possible (but it takes more computational power).
detable_18_27 <- FindAllMarkers(DGE_DATA,
                          only.pos = TRUE,
                          max.cells.per.ident = 300,
                          logfc.threshold = .1,
                          assay = "RNA",
                          min.pct = 0.05)

# Only keep DEGs that have a p-value below 0.05.
detable_18_27 <- detable_18_27[detable_18_27$p_val < 0.05, ]

# Adding two extra columns giving the difference (and log difference) between pct1 and pct2.
# pct1 is the percentage of cells in the specific cluster that express this gene.
# pct2 is the percentage of cells in all other clusters that express this gene.
detable_18_27$pct.diff <- detable_18_27$pct.1 - detable_18_27$pct.2
detable_18_27$log.pct.diff <- log2((detable_18_27$pct.1*99+1) / (detable_18_27$pct.2*99+1))

# Save the detable as a csv file.
write.csv2(detable_18_27, paste0(myfolder, "detable_rough_clusters_18_27.csv"))

# Pick the 60 genes with the lowest p value for each age group, then 40 highest based on pct.diff, then 20 highest based on log.pct.diff.
# This gives a total of 140 genes (20 per age group).
detable_18_27 %>%
  group_by(cluster) %>%
  top_n(-60, p_val) %>%
  top_n(40, pct.diff) %>%
  top_n(20, log.pct.diff) ->
  top20

# Genes get matched to one specific cluster and the factor is leveled based on cluster number.
ord <- factor(sapply(unique(as.character(top20$gene)), function(x){niceRplots::getcluster(DGE_DATA, x, "clusters_louvain_oi")}))

pdf(paste0(myfolder, "DGE_rough_18_27.pdf"), width = 15, height = 10)
par(mfrow=c(1,1), mar=c(3,6,2,5))
DotPlot(DGE_DATA, features = unique(as.character(top20$gene))[order(as.numeric(as.character(ord)))]) +
  coord_flip() +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete(limits = rev) +
  scale_y_discrete() +
  labs(x = "", y = "") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
dev.off()

rm(detable_18_27, DGE_DATA, top20, DGE_cells, ord, sample_size)
```


## Export Seurat object before adding the annotation

```{r}
saveRDS(data, paste0(myfolder, "rds_objects/HDCA_heart_sc_full_before_annotation.rds"))
```

```{r}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_full_before_annotation.rds"))
```


### Merge clusters 4 & 35

Based on the DEG, clusters 4 and 35 were merged as a unique cell type.

```{r}
df <- data.frame(matrix(ncol = 2, nrow = length(colnames(data))))
colnames(df) <- c("data_cluster", "clusters_comb")
df$data_cluster <- data@meta.data$clusters_louvain_oi

df$clusters_comb <- ifelse(is.na(df$clusters_comb), df$data_cluster, df$clusters_comb)
df$clusters_comb <- ifelse(df$clusters_comb == 4, "4_35", df$clusters_comb)
df$clusters_comb <- ifelse(df$clusters_comb == 35, "4_35", df$clusters_comb)

data$high_level_clusters <- factor(df$clusters_comb, levels = c(1, 2, 3, "4_35", 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, "18_1", "18_2", 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34))
```


### Subcluster (cluster 18)

Based on the DEG, cluster 18 was selected and umap clustering was made on it separately. The subsequent 2 clusters were added to the high level clusters. 

```{r}
cl18 <- data[, as.character(data$clusters_louvain_oi) == "18"] %>% 
  RunUMAP(dims = 1:50,
          reduction = "harmony_oi",
          n.neighbors = 30,
          n.epochs = 100,
          n.threads = 7,
          reduction.key = "subset",
          reduction.name = "umap_subset_cl18")

# Compute k nearest neighbours
nn <- CreateNNAdjacencyMatrix(data = cl18, reduction = "harmony_oi", k = 30, dims = 1:50)

# Create an undirected graph based on the neighbor matrix.
cl <- LouvainClustering(nn = nn, resolution = 0.25)
cl18$clusters_subset_cl18 <- factor(cl)

pdf(paste0(myfolder, "subset_high_cl18.pdf"), width = 10, height = 10)
DimPlot(cl18, reduction = "umap_subset_cl18", group.by = "clusters_subset_cl18", label = TRUE) + NoLegend()
dev.off()
```

```{r}
cl18 <- SetIdent(cl18, value = "clusters_subset_cl18")
de_markers_cl18 <- FindAllMarkers(cl18, only.pos = TRUE, logfc.threshold = 0.5) %>% 
  filter(p_val_adj < 0.01)

openxlsx::write.xlsx(de_markers_cl18 %>% filter(p_val_adj < 0.01),
                     file = paste0(myfolder, "detable_cardiomyocytes_cl18.xlsx"))

p <- DotPlot(cl18, features = de_markers_cl18 %>% group_by(cluster) %>% 
          slice_head(n = 10) %>% pull(gene) %>% unique()) +
  coord_flip() +  # This flips the plot vertically
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete(limits = rev) +
  labs(x = "Genes", y = "Cluster")  # Flipped labels

pdf(paste0(myfolder, "dotplot_de_genes_cl18.pdf"), width = 10, height = 7)
print(p)
dev.off()
```


### Add cl18 subclusters

```{r}
cl18_split <- cl18[[]] %>% 
  select(clusters_subset_cl18) %>% 
  rename(clusters_subset_split = clusters_subset_cl18)


new_ids <- data[[]] %>% select(high_level_clusters)
new_ids[, "clusters_subset_split"] <- cl18_split[colnames(data), "clusters_subset_split", drop = TRUE]

new_ids <- new_ids %>% 
  mutate_if(is.factor, as.character) %>% 
  mutate(clusters_subset_split = case_when(!is.na(clusters_subset_split) ~ paste0("18_", clusters_subset_split),
                                           TRUE ~ high_level_clusters))

# rename "high_level_clusters" with the clusters 18 split
data$high_level_clusters <- new_ids$clusters_subset_split

rm(cl18, cl18_split, new_ids, nn)
```


### Visualize clusters merged

```{r}
pdf(paste0(myfolder, "clusters_high_level_merged_and_split.pdf"), width = 15, height = 15)
DimPlot(data, reduction = "umap_oi", group.by = "high_level_clusters", label = T, raster = F) + labs(title = "High level clusters")
dev.off()
```


### Remove low quality clusters (6, 19, 27, 34)

```{r}
data$high_level_clusters_removed <- factor(data$high_level_clusters, levels = c(1, 2, 3, "4_35", 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, "18_1", "18_2", 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33))

pdf(paste0(myfolder, "clusters_removed_before_annotation.pdf"), width = 15, height = 15)
DimPlot(data[, as.character(data$high_level_clusters_removed) %in% levels(data$high_level_clusters_removed)], reduction = "umap_oi", group.by = "high_level_clusters_removed", label = TRUE)
dev.off()

rm(df)
gc()
```


## Export Seurat object with final high level clusters before annotation

```{r}
saveRDS(data, paste0(myfolder, "rds_objects/HDCA_heart_sc_full_before_annotation02.rds"))
```

```{r}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_full_before_annotation02.rds"))
```


## Add the annotation

The annotation was imported from an external .csv file. The annotation is added as a new metadata row `cell.types` by matching the cluster numbers.

```{r}
annotation <- read.csv2("/home/rstudio/project/data/metadata/hl_annotation_2023-08-23.csv", header = 1, sep = ";")
cells_clusters <- setNames(annotation$cell_type, nm = annotation$cluster)
data$cell.types <- cells_clusters[as.character(data$high_level_clusters)]
rm(annotation, cells_clusters)
gc()
```


## *After annotation*

### Plot UMAP with annotations

```{r}
pdf(paste0(myfolder, "annotation.pdf"), width = 20, height = 15)
DimPlot(data[, as.character(data$high_level_clusters_removed) %in% levels(data$high_level_clusters_removed)], reduction = "umap_oi", group.by = "cell.types", label = TRUE)
dev.off()
gc()
```


### Add additional age groups to the metadata

```{r}
df <- data.frame(age = c(5.5, 6, 7, 8, 8.5, 9, 10, 11.5, 12, 13.25, 14), age_group = c("5-6", "5-6", "7-8", "7-8", "7-8", "9-11", "9-11", "9-11", "12-14", "12-14", "12-14"))
age_to_age_group <- setNames(df$age_group, nm = df$age)
data$age_groups <- factor(age_to_age_group[as.character(data$age)], levels = c("5-6", "7-8", "9-11", "12-14"))
rm(df)
gc()
```


## Export Seurat object (final High Level Seurat object)

```{r}
saveRDS(data, paste0(myfolder, "rds_objects/HDCA_heart_sc_full_extended.rds"))
```

```{r}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_full_extended.rds"))
```


## Calculate differentially expressed genes (DEG) after annotation

```{r}
# Select a new samples size for each cluster, to get groups that are equally (or almost equally) large.
sample_size <- table(data$high_level_clusters_removed)
sample_size[sample_size > 150] <- 150
sample_size

# Randomly sample the cells that will be included when calculating DGE (same number of cells as selected above).
# Samples without replacement, so each cell only can be included once.
DGE_cells <- lapply(names(sample_size), function(x){ 
  set.seed(1)
  sample(colnames(data)[data$high_level_clusters_removed == x], size = sample_size[x])
  })
DGE_cells <- unlist(DGE_cells)

# Select all data that relates to the sampled DGE cells.
DGE_DATA <- data[, DGE_cells]

#Find differentially expressed genes based on groups defined by "high_level_clusters_removed".
DGE_DATA <- SetIdent(DGE_DATA, value = "high_level_clusters_removed")

# The logfc threshold is set to 0.1 as compared to the default 0.25, which makes the detection of weaker signals possible (but it takes more computational power).
detable <- FindAllMarkers(DGE_DATA,
                          only.pos = TRUE,
                          max.cells.per.ident = 300,
                          logfc.threshold = .1,
                          assay = "RNA",
                          min.pct = 0.05)

# Only keep DEGs that have a p-value below 0.05.
detable <- detable[detable$p_val < 0.05, ]

# Adding two extra columns giving the difference (and log difference) between pct1 and pct2.
# pct1 is the percentage of cells in the specific cluster that express this gene.
# pct2 is the percentage of cells in all other clusters that express this gene.
detable$pct.diff <- detable$pct.1 - detable$pct.2
detable$log.pct.diff <- log2((detable$pct.1*99+1) / (detable$pct.2*99+1))

# Save the detable as a csv file.
write.csv2(detable, paste0(myfolder, "detable_rough_clusters.csv"))

# Pick the 60 genes with the lowest p value for each group, then 40 highest based on pct.diff, then 20 highest based on log.pct.diff.
# This gives a total of 140 genes (20 per group).
detable %>%
  group_by(cluster) %>%
  top_n(-60, p_val) %>%
  top_n(40, pct.diff) %>%
  top_n(20, log.pct.diff) ->
  top20

# Genes get matched to one specific cluster and the factor is leveled based on cluster number.
ord <- factor(sapply(unique(as.character(top20$gene)), function(x){niceRplots::getcluster(DGE_DATA, x, "high_level_clusters_removed")}))

pdf(paste0(myfolder, "DGE_rough_after_ann.pdf"), width = 15, height = 115)
par(mfrow=c(1,1), mar=c(3,6,2,5))
DotPlot(DGE_DATA, features = unique(as.character(top20$gene))[order(as.numeric(as.character(ord)))]) +
  coord_flip() +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete(limits = rev) +
  scale_y_discrete() +
  labs(x = "", y = "") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
dev.off()

gc()
```


### Functional enrichment analysis (FEA)

Using `gprofiler2` using the sources "Biological Process" (BP) from "Gene Ontology" (GO:BP) and "REAC" from Reactome.

```{r}
GeneSets <- detable %>%
  filter(p_val_adj < 0.01, avg_log2FC > 0.5) %>%
  group_by(cluster) %>%
  group_split()

pathways <- lapply(seq_along(GeneSets), function(i) {
  print(i)
  set <- GeneSets[[i]]
  res <- gost(query = set$gene, organism = "hsapiens", sources = c("GO:BP", "REAC"), significant = FALSE)
  return(res$result)
})
pathways <- setNames(pathways, nm = paste0(unique(detable$cluster)))

openxlsx::write.xlsx(pathways, file = paste0(myfolder, "HL_fea_cluster_removed_split.xlsx"))
```


## Age groups

```{r}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_full_extended.rds"))
```


### Create the age groups

5-6 weeks
7-8 weeks
9-11 weeks
12-14 weeks

```{r}
age1 <- data[,data$age <= 6]
age2 <- data[,data$age == 7 | data$age == 8 | data$age == 8.5]
age3 <- data[,data$age == 9 | data$age == 10 | data$age == 11.5]
age4 <- data[,data$age >= 12]
```


#### Check cell group (age) with the fewest cells

```{r}
a1 <- sum(table(age1$sampleID))
a2 <- sum(table(age2$sampleID))
a3 <- sum(table(age3$sampleID))
a4 <- sum(table(age4$sampleID))
min_cell <- min(a1, a2, a3, a4)
min_cell
rm(a1, a2, a3, a4)
```


### Select random subsets of the same size

To 8742 cells (same size as the smallest age group, i.e., age3).

```{r}
set.seed(1) ; age1 <- age1[, sample(colnames(age1), size = min_cell)]
set.seed(1) ; age2 <- age2[, sample(colnames(age2), size = min_cell)]
set.seed(1) ; age3 <- age3[, sample(colnames(age3), size = min_cell)]
set.seed(1) ; age4 <- age4[, sample(colnames(age4), size = min_cell)]

ages <- c(age1, age2, age3, age4)

rm(age1, age2, age3, age4)
gc()
```


## Export Seurat object

```{r}
saveRDS(ages, paste0(myfolder, "rds_objects/HDCA_heart_sc_age_groups.rds"))
```

```{r}
ages <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_age_groups.rds"))
```


### Temporal evolution of High Level UMAP

```{r}
pdf(file = paste0(myfolder, "Clusters_age_5_to_6_weeks_full_size.pdf"), width = 15, height = 15, bg = "transparent")
DimPlot(ages[[1]][, as.character(ages[[1]]$high_level_clusters_removed) %in% levels(ages[[1]]$high_level_clusters_removed)], reduction = "umap_oi", group.by = "cell.types", raster = F, pt.size = 1) + NoLegend()
dev.off()

pdf(file = paste0(myfolder, "Clusters_age_7_to_8_weeks_full_size.pdf"), width = 15, height = 15, bg = "transparent")
DimPlot(ages[[2]][, as.character(ages[[2]]$high_level_clusters_removed) %in% levels(ages[[2]]$high_level_clusters_removed)], reduction = "umap_oi", group.by = "cell.types", raster = F, pt.size = 1) + NoLegend()
dev.off()

pdf(file = paste0(myfolder, "Clusters_age_9_to_11_weeks_full_size.pdf"), width = 15, height = 15, bg = "transparent")
DimPlot(ages[[3]][, as.character(ages[[3]]$high_level_clusters_removed) %in% levels(ages[[3]]$high_level_clusters_removed)], reduction = "umap_oi", group.by = "cell.types", raster = F, pt.size = 1) + NoLegend()
dev.off()

pdf(file = paste0(myfolder, "Clusters_age_12_to_14_weeks_full_size.pdf"), width = 15, height = 15, bg = "transparent")
DimPlot(ages[[4]][, as.character(ages[[4]]$high_level_clusters_removed) %in% levels(ages[[4]]$high_level_clusters_removed)], reduction = "umap_oi", group.by = "cell.types", raster = F, pt.size = 1) + NoLegend()
dev.off()
```


### Cell type proportion by age group in entire data

```{r}
age1 <- data[,data$age <= 6]
age2 <- data[,data$age == 7 | data$age == 8 | data$age == 8.5]
age3 <- data[,data$age == 9 | data$age == 10 | data$age == 11.5]
age4 <- data[,data$age >= 12]

data_age <- c(age1, age2, age3, age4)
rm(age1, age2, age3, age4)


# create df by age grouping the number of cell per cluster
cell_by_cluster_entire_1 <- as.data.frame(table(data_age[[1]]@meta.data[["cell.types"]]))
cell_by_cluster_entire_2 <- as.data.frame(table(data_age[[2]]@meta.data[["cell.types"]]))
cell_by_cluster_entire_3 <- as.data.frame(table(data_age[[3]]@meta.data[["cell.types"]]))
cell_by_cluster_entire_4 <- as.data.frame(table(data_age[[4]]@meta.data[["cell.types"]]))

# add the proportion of each cell type
cell_by_cluster_entire_1$proportion <- cell_by_cluster_entire_1$Freq/sum(cell_by_cluster_entire_1$Freq)
cell_by_cluster_entire_2$proportion <- cell_by_cluster_entire_2$Freq/sum(cell_by_cluster_entire_2$Freq)
cell_by_cluster_entire_3$proportion <- cell_by_cluster_entire_3$Freq/sum(cell_by_cluster_entire_3$Freq)
cell_by_cluster_entire_4$proportion <- cell_by_cluster_entire_4$Freq/sum(cell_by_cluster_entire_4$Freq)

# export the df as .csv
write.csv2(cell_by_cluster_entire_1, paste0(myfolder, "cell_by_cluster_entire_1.csv"))
write.csv2(cell_by_cluster_entire_2, paste0(myfolder, "cell_by_cluster_entire_2.csv"))
write.csv2(cell_by_cluster_entire_3, paste0(myfolder, "cell_by_cluster_entire_3.csv"))
write.csv2(cell_by_cluster_entire_4, paste0(myfolder, "cell_by_cluster_entire_4.csv"))
```


## DotPlots

### High Level dotplot from selected markers

```{r}
# specific list of marker to project the dotplot on
my_markers <- c("MYH7", "MYH6", "MYBPC3", "TNNI1", "MYOZ2", "FABP3", "TMSB10", "S100A11", "GNG11", "FABP4", "VWF", "CDH5", "PECAM1", "LYVE1", "NPR3", "BMPER", "POSTN", "APCDD1", "TWIST1", "DDR2", "TCF21", "COL1A1", "MYH11", "ENPEP", "ITLN1", "PCSK1N", "MPZ", "C1QC", "JCHAIN", "CD3E", "KLRB1")

# remove undesired cells
cells_to_remove <- data$cell.types == "Immature RBC + PLT" | 
                   data$cell.types == "Mixed low quality cells" | 
                   data$cell.types == "RBC" | 
                   data$cell.types == "Cardiomyocytes - check quality/sample distribution!"

data_HL <- data[,!cells_to_remove]
rm(cells_to_remove)

# reorder the cell types desired
data_HL$high_level_clusters_removed <- factor(data_HL$cell.types, 
                                              levels = c("Ventricular CM_1",
                                                         "Atrial CM_1",
                                                         "Ventricular CM_2",
                                                         "Ventricular CM_3",
                                                         "Atrial CM_2",
                                                         "Proliferating CM",
                                                         "Immature CM",
                                                         "TMSB10high_1",
                                                         "TMSB10high_2",
                                                         "Macrovascular EC",
                                                         "Microvascular EC",
                                                         "SEMA4Ahigh EC",
                                                         "Lymphatic EC",
                                                         "Endocardial EC",
                                                         "Valve-related EC",
                                                         "Valve-related FB",
                                                         "SEMA4Ahigh FB",
                                                         "Interstitial FB",
                                                         "Vessel-related FB",
                                                         "Outflow tract FB",
                                                         "Epicardium-derived progenitor cells",
                                                         "Atrioventricular plane FB",
                                                         "Proliferating FB",
                                                         "Outflow tract SMC",
                                                         "Coronary SMC",
                                                         "Pericytes",
                                                         "Epicardial cells",
                                                         "Cardiac neural crest cells",
                                                         "Schwann cell progenitor cells",
                                                         "Myeloid cells",
                                                         "Lymphoid cells"
                                                         ))

data_HL <- SetIdent(data_HL, value = "high_level_clusters_removed")

p <- DotPlot(data_HL, features = my_markers) +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete() +
  scale_y_discrete(limits = rev) +
  labs(x = "", y = "") + 
  theme(axis.text.x = element_text(angle = 30, hjust = 1, size = 8))

pdf(paste0(myfolder, "HL_dotplot_DEG.pdf"), width = 13, height = 11)
print(p)
dev.off()

rm(p)
gc()
```


### High Level dotplot from selected markers

```{r}
# specific list of marker to project the dotplot on
my_markers <- c("MT3", "HEY2", "NREP", "CKM", "FHL2", "MB", "LGALS3", "IRX3", "MASP1", "PPP1R12B", "ANGPT1", "BMP10", "DKK3", "PITX2", "ADAMTS8", "COL2A1", "ACTA1", "NPPB", "PGK1")

# remove undesired cells
cells_to_remove <- data$cell.types == "Immature RBC + PLT" | 
                   data$cell.types == "Mixed low quality cells" | 
                   data$cell.types == "RBC" | 
                   data$cell.types == "Cardiomyocytes - check quality/sample distribution!"

data_HL <- data[,!cells_to_remove]
rm(cells_to_remove)

# reorder the cell types desired
data_HL$high_level_clusters_removed <- factor(data_HL$cell.types, 
                                              levels = c("Ventricular CM_1",
                                                         "Atrial CM_1",
                                                         "Ventricular CM_2",
                                                         "Ventricular CM_3",
                                                         "Atrial CM_2",
                                                         "Proliferating CM",
                                                         "Immature CM",
                                                         "TMSB10high_1",
                                                         "TMSB10high_2",
                                                         "Macrovascular EC",
                                                         "Microvascular EC",
                                                         "SEMA4Ahigh EC",
                                                         "Lymphatic EC",
                                                         "Endocardial EC",
                                                         "Valve-related EC",
                                                         "Valve-related FB",
                                                         "SEMA4Ahigh FB",
                                                         "Interstitial FB",
                                                         "Vessel-related FB",
                                                         "Outflow tract FB",
                                                         "Epicardium-derived progenitor cells",
                                                         "Atrioventricular plane FB",
                                                         "Proliferating FB",
                                                         "Outflow tract SMC",
                                                         "Coronary SMC",
                                                         "Pericytes",
                                                         "Epicardial cells",
                                                         "Cardiac neural crest cells",
                                                         "Schwann cell progenitor cells",
                                                         "Myeloid cells",
                                                         "Lymphoid cells"
                                                         ))

data_HL <- SetIdent(data_HL, value = "high_level_clusters_removed")

p <- DotPlot(data_HL, features = my_markers) +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete() +
  scale_y_discrete(limits = rev) +
  labs(x = "", y = "") + 
  theme(axis.text.x = element_text(angle = 30, hjust = 1, size = 8))

pdf(paste0(myfolder, "HL_dotplot_DEG_fig2.pdf"), width = 13, height = 11)
print(p)
dev.off()

rm(p)
gc()
```


### High Level dotplot from ST enriched markers

```{r}
# specific list of marker to project the dotplot on
my_markers_ST <- c("COL2A1", "PITX2", "ADAMTS8", "DUOX2", "MYH6", "PAM", "DUOXA2", "NPPA", "BMP10", "DKK3", "ATP2A2", "NR2F1", "ANGPT1", "NREP", "HEY2", "MT3", "MYH7", "CKM", "MYL2", "LGALS3", "IRX3", "TGM2", "MB", "MASP1", "FHL2", "PPP1R12B", "NUDT4", "POSTN", "IRX1", "ATP1B4", "SEMA3A", "IRX2", "RCAN1", "EPHA4", "RSPO3", "NELL2", "HAMP", "BMP2", "TBX3", "SPON1", "DOK4", "IGFBP5", "ACTA1", "COL1A2", "COL1A1", "PTN", "TAGLN", "TNFRSF19", "NPPB", "MIF", "LDHA", "BNIP3", "ENO1", "SLC2A1"
)

# remove undesired cells
cells_to_remove <- data$cell.types == "Immature RBC + PLT" | 
                   data$cell.types == "Mixed low quality cells" | 
                   data$cell.types == "RBC" | 
                   data$cell.types == "Cardiomyocytes - check quality/sample distribution!"

data_HL <- data[,!cells_to_remove]
rm(cells_to_remove)

# reorder the cell types desired
data_HL$high_level_clusters_removed <- factor(data_HL$cell.types, 
                                              levels = c("Ventricular CM_1",
                                                         "Atrial CM_1",
                                                         "Ventricular CM_2",
                                                         "Ventricular CM_3",
                                                         "Atrial CM_2",
                                                         "Proliferating CM",
                                                         "Immature CM",
                                                         "TMSB10high_1",
                                                         "TMSB10high_2",
                                                         "Macrovascular EC",
                                                         "Microvascular EC",
                                                         "SEMA4Ahigh EC",
                                                         "Lymphatic EC",
                                                         "Endocardial EC",
                                                         "Valve-related EC",
                                                         "Valve-related FB",
                                                         "SEMA4Ahigh FB",
                                                         "Interstitial FB",
                                                         "Vessel-related FB",
                                                         "Outflow tract FB",
                                                         "Epicardium-derived progenitor cells",
                                                         "Atrioventricular plane FB",
                                                         "Proliferating FB",
                                                         "Outflow tract SMC",
                                                         "Coronary SMC",
                                                         "Pericytes",
                                                         "Epicardial cells",
                                                         "Cardiac neural crest cells",
                                                         "Schwann cell progenitor cells",
                                                         "Myeloid cells",
                                                         "Lymphoid cells"
                                                         ))

data_HL <- SetIdent(data_HL, value = "high_level_clusters_removed")

p <- DotPlot(data_HL, features = my_markers_ST) +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete() +
  scale_y_discrete(limits = rev) +
  labs(x = "", y = "") + 
  theme(axis.text.x = element_text(angle = 30, hjust = 1, size = 8))

pdf(paste0(myfolder, "HL_dotplot_DEG_ST_markers.pdf"), width = 16, height = 11)
print(p)
dev.off()

rm(p)
gc()
```


### DEG rough CM top5

```{r}
# Select a new samples size for each cluster, to get groups that are equally (or almost equally) large.
data_CM <- data[, data$high_level_clusters_removed == "4_35" |
                  data$high_level_clusters_removed == "5"    |
                  data$high_level_clusters_removed ==  "7"   |
                  data$high_level_clusters_removed == "9"    |
                  data$high_level_clusters_removed ==  "11"  |
                  data$high_level_clusters_removed == "17"   |
                  data$high_level_clusters_removed == "18_2" ]

sample_size <- table(data_CM$high_level_clusters_removed)
sample_size[sample_size > 1500] <- 1500
sample_size

# Randomly sample the cells that will be included when calculating DGE (same number of cells as selected above).
# Samples without replacement, so each cell only can be included once.
DGE_cells <- lapply(names(sample_size), function(x){ 
  set.seed(1)
  sample(colnames(data_CM)[data_CM$high_level_clusters_removed == x], size = sample_size[x])
  })
DGE_cells <- unlist(DGE_cells)

# Select all data that relates to the sampled DGE cells.
DGE_DATA <- data_CM[, DGE_cells]

# reorder the cell types desired
DGE_DATA$high_level_clusters_removed <- factor(DGE_DATA$high_level_clusters_removed, 
                                              levels = c("4_35", "17", "9", "5", "11", "7", "18_2"))

#Find differential expressed genes based on groups defined by "high_level_clusters_removed".
DGE_DATA <- SetIdent(DGE_DATA, value = "high_level_clusters_removed")

# The logfc threshold is set to 0.1 as compared to the default 0.25, which makes the detection of weaker signals possible (but it takes more computational power).
detable <- FindAllMarkers(DGE_DATA,
                          only.pos = TRUE,
                          max.cells.per.ident = 300,
                          logfc.threshold = .1,
                          assay = "RNA",
                          min.pct = 0.05)

# Only keep DEG that have a p-value below 0.05.
detable <- detable[detable$p_val < 0.05, ]

# Adding two extra columns giving the difference (and log difference) between pct1 and pct2.
# pct1 is the percentage of cells in the specific cluster that express this gene.
# pct2 is the percentage of cells in all other clusters that express this gene.
detable$pct.diff <- detable$pct.1 - detable$pct.2
detable$log.pct.diff <- log2((detable$pct.1*99+1) / (detable$pct.2*99+1))

# Save the detable as a csv file.
write.csv2(detable, paste0(myfolder, "cardiomyocytes/detable_rough_CM.csv"))

# Pick the 30 genes with the lowest p value for cluster, then 20 highest based on log.pct.diff, then 5 highest based on avg_log2FC.
detable %>%
  group_by(cluster) %>%
  top_n(-30, p_val) %>%
  top_n(20, log.pct.diff) %>%
  top_n(5, avg_log2FC) ->
  top5

pdf(paste0(myfolder, "cardiomyocytes/DGE_rough_CM_top5.pdf"), width = 7, height = 8)
par(mfrow=c(1,1), mar=c(3,6,2,5))
DotPlot(DGE_DATA, features = top5 %>% pull(gene) %>% unique()) +
  coord_flip() +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete(limits = rev) +
  scale_y_discrete() +
  labs(x = "", y = "") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
dev.off()

rm(detable, DGE_DATA, top5, DGE_cells, ord, sample_size)
```


#### CM from High Level dotplot from selected markers

```{r}
data_CM <- data[, data$high_level_clusters_removed == "4_35" |
                  data$high_level_clusters_removed == "5"    |
                  data$high_level_clusters_removed ==  "7"   |
                  data$high_level_clusters_removed == "9"    |
                  data$high_level_clusters_removed ==  "11"  |
                  data$high_level_clusters_removed == "17"   |
                  data$high_level_clusters_removed == "18_2" ]

# specific list of marker to project the dotplot on
# my_markers <- c("MYH6", "MYH7", "MYL7", "MYL2", "TNNI1", "TNNI3", "KCNJ2", "KCNJ12", "SCN5A", "CACNA1C", "CACNB2", "RYR2", "ATP2A2", "SLC8A1", "JPH2", "NEXN", "MFN1", "MFN2", "HK1", "HK2", "PKM", "ALDOA", "ENO1", "PPARGC1A", "PPARGC1B", "PPARA", "ESRRA", "ESRRB", "ESRRG", "NRF1", "COX8A", "GJA1", "OPA1", "MICOS10", "MICOS13", "SRF", "MRTFA", "MRTFB", "HOPX", "NDUFA1", "NDUFB4", "SDHD", "SDHC", "UQCRH", "UQCRB", "UQCR11", "COX7C", "COX5A", "ATP5MC2", "ATP5MC3", "ATP5MD", "DRP1", "NRF2", "COX8B", "COX6B")

my_markers <- c("MYH6", "MYH7", "MYL2", "MYL3", "MYL4", "MYL7", "CSRP3", "MYOZ2", "ACTN2", "TTN", "TNNI1", "TNNI3", "TNNC1", "TNNT2", "TPM1", "TPM2", "CACNA1C", "CACNB2", "RYR2", "ATP2A2", "SLC8A1", "PLN", "JPH2", "NEXN", "PPARGC1A", "ESRRG", "OPA1", "HK1", "HK2", "PKM", "ALDOA", "ENO1", "NDUFA1", "NDUFB4", "UQCRH", "UQCRB", "COX7C", "COX5A", "ATP5F1A", "ATP5MD"
)

# reorder the cell types desired
data_CM$high_level_clusters_removed <- factor(data_CM$high_level_clusters_removed, 
                                              levels = c("4_35", "17", "9", "5", "11", "7", "18_2"))

data_CM <- SetIdent(data_CM, value = "high_level_clusters_removed")

pdf(paste0(myfolder, "cardiomyocytes/dotplot_markers_high_level_CM_2.pdf"), width = 7, height = 10)
par(mfrow=c(1,1), mar=c(3,6,2,5))
DotPlot(data_CM, features = my_markers) +
  coord_flip() +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete(limits = rev) +
  scale_y_discrete() +
  #labs(x = "", y = "") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
dev.off()

rm(p)
gc()
```


### DEG rough EN top5

```{r}
# Select a new samples size for each cluster, to get groups that are equally (or almost equally) large.
data_EN <- data[, data$high_level_clusters_removed == "3"   |
                  data$high_level_clusters_removed == "12"  |
                  data$high_level_clusters_removed ==  "21" |
                  data$high_level_clusters_removed == "24"  |
                  data$high_level_clusters_removed ==  "28" |
                  data$high_level_clusters_removed == "32"  ]

sample_size <- table(data_EN$high_level_clusters_removed)
sample_size[sample_size > 500] <- 500
sample_size

# Randomly sample the cells that will be included when calculating DGE (same number of cells as selected above).
# Samples without replacement, so each cell only can be included once.
DGE_cells <- lapply(names(sample_size), function(x){ 
  set.seed(1)
  sample(colnames(data_EN)[data_EN$high_level_clusters_removed == x], size = sample_size[x])
  })
DGE_cells <- unlist(DGE_cells)

# Select all data that relates to the sampled DGE cells.
DGE_DATA <- data_EN[, DGE_cells]

# reorder the cell types desired
DGE_DATA$high_level_clusters_removed <- factor(DGE_DATA$high_level_clusters_removed, 
                                              levels = c("28", "12", "24", "32", "3", "21"))

#Find differential expressed genes based on groups defined by "high_level_clusters_removed".
DGE_DATA <- SetIdent(DGE_DATA, value = "high_level_clusters_removed")

# The logfc threshold is set to 0.1 as compared to the default 0.25, which makes the detection of weaker signals possible (but it takes more computational power).
detable <- FindAllMarkers(DGE_DATA,
                          only.pos = TRUE,
                          max.cells.per.ident = 300,
                          logfc.threshold = .1,
                          assay = "RNA",
                          min.pct = 0.05)

# Only keep DEG that have a p-value below 0.05.
detable <- detable[detable$p_val < 0.05, ]

# Adding two extra columns giving the difference (and log difference) between pct1 and pct2.
# pct1 is the percentage of cells in the specific cluster that express this gene.
# pct2 is the percentage of cells in all other clusters that express this gene.
detable$pct.diff <- detable$pct.1 - detable$pct.2
detable$log.pct.diff <- log2((detable$pct.1*99+1) / (detable$pct.2*99+1))

# Save the detable as a csv file.
write.csv2(detable, paste0(myfolder, "endothelial/detable_rough_EN.csv"))

# Pick the 30 genes with the lowest p value for cluster, then 20 highest based on log.pct.diff, then 5 highest based on avg_log2FC.
detable %>%
  group_by(cluster) %>%
  top_n(-30, p_val) %>%
  top_n(20, log.pct.diff) %>%
  top_n(5, avg_log2FC) ->
  top5

pdf(paste0(myfolder, "endothelial/DGE_rough_EN_top5.pdf"), width = 7, height = 8)
par(mfrow=c(1,1), mar=c(3,6,2,5))
DotPlot(DGE_DATA, features = top5 %>% pull(gene) %>% unique()) +
  coord_flip() +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete(limits = rev) +
  scale_y_discrete() +
  labs(x = "", y = "") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
dev.off()

rm(detable, DGE_DATA, top5, DGE_cells, ord, sample_size)
```


### DEG rough FB top5

```{r}
# Select a new samples size for each cluster, to get groups that are equally (or almost equally) large.
data_FB <- data[, data$high_level_clusters_removed == "1"   |
                  data$high_level_clusters_removed == "2"   |
                  data$high_level_clusters_removed == "13"  |
                  data$high_level_clusters_removed == "14"  |
                  data$high_level_clusters_removed == "16"  |
                  data$high_level_clusters_removed == "23"  |
                  data$high_level_clusters_removed == "30"  |
                  data$high_level_clusters_removed == "31"  ]

sample_size <- table(data_FB$high_level_clusters_removed)
sample_size[sample_size > 500] <- 500
sample_size

# Randomly sample the cells that will be included when calculating DGE (same number of cells as selected above).
# Samples without replacement, so each cell only can be included once.
DGE_cells <- lapply(names(sample_size), function(x){ 
  set.seed(1)
  sample(colnames(data_FB)[data_FB$high_level_clusters_removed == x], size = sample_size[x])
  })
DGE_cells <- unlist(DGE_cells)

# Select all data that relates to the sampled DGE cells.
DGE_DATA <- data_FB[, DGE_cells]

# reorder the cell types desired
DGE_DATA$high_level_clusters_removed <- factor(DGE_DATA$high_level_clusters_removed, 
                                              levels = c("13", "30", "2", "23", "1", "14", "16", "31"))

#Find differential expressed genes based on groups defined by "high_level_clusters_removed".
DGE_DATA <- SetIdent(DGE_DATA, value = "high_level_clusters_removed")

# The logfc threshold is set to 0.1 as compared to the default 0.25, which makes the detection of weaker signals possible (but it takes more computational power).
detable <- FindAllMarkers(DGE_DATA,
                          only.pos = TRUE,
                          max.cells.per.ident = 300,
                          logfc.threshold = .1,
                          assay = "RNA",
                          min.pct = 0.05)

# Only keep DEG that have a p-value below 0.05.
detable <- detable[detable$p_val < 0.05, ]

# Adding two extra columns giving the difference (and log difference) between pct1 and pct2.
# pct1 is the percentage of cells in the specific cluster that express this gene.
# pct2 is the percentage of cells in all other clusters that express this gene.
detable$pct.diff <- detable$pct.1 - detable$pct.2
detable$log.pct.diff <- log2((detable$pct.1*99+1) / (detable$pct.2*99+1))

# Save the detable as a csv file.
write.csv2(detable, paste0(myfolder, "fibroblast/detable_rough_FB.csv"))

# Pick the 30 genes with the lowest p value for cluster, then 20 highest based on log.pct.diff, then 5 highest based on avg_log2FC.
detable %>%
  group_by(cluster) %>%
  top_n(-30, p_val) %>%
  top_n(20, log.pct.diff) %>%
  top_n(5, avg_log2FC) ->
  top5

pdf(paste0(myfolder, "fibroblast/DGE_rough_FB_top5.pdf"), width = 8, height = 8)
par(mfrow=c(1,1), mar=c(3,6,2,5))
DotPlot(DGE_DATA, features = top5 %>% pull(gene) %>% unique()) +
  coord_flip() +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete(limits = rev) +
  scale_y_discrete() +
  labs(x = "", y = "") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
dev.off()

rm(detable, DGE_DATA, top5, DGE_cells, ord, sample_size)
```


## nFeature and nCount plots on UMAP

```{r}
#Projection on UMAP
pdf(paste0(myfolder, "p_UMAP_nCount_RNA_after_filter.pdf"), width = 15, height = 15)
FeaturePlot(data, reduction = "umap_oi", features = "nCount_RNA", raster = FALSE)
dev.off()

pdf(paste0(myfolder, "p_UMAP_nFeature_RNA_after_filter.pdf"), width = 15, height = 15)
FeaturePlot(data, reduction = "umap_oi", features = "nFeature_RNA", raster = FALSE)
dev.off()
```


## UMAP 3D

```{r}
data <- RunUMAP(data,
                dims = 1:50,
                reduction = "harmony_oi",
                n.neighbors = 10,
                metric = "cosine",
                min.dist = 0.3,
                spread = 1,
                repulsion.strength = 1,
                negative.sample.rate = 5,
                n.epochs = 100,
                reduction.key = "oi_",
                reduction.name = "umap_oi_3d",
                seed.use = 42,
                n.components = 3)
gc()

df_data <- data.frame(data@reductions$umap_oi_3d@cell.embeddings)
df_data <- data.frame(df_data, seurat_clusters=data$cell.types, sampleid = data$sampleID , age = data$age)
colnames(df_data)[1:3] <- c("UMAP_1", "UMAP_2", "UMAP_3")
pal <- c(scales::hue_pal()(8), RColorBrewer::brewer.pal(9, "Set1"), RColorBrewer::brewer.pal(8, "Set2"))

p <- plot_ly(df_data, 
             x = ~UMAP_1, y = ~UMAP_2, z = ~UMAP_3,
             color = ~seurat_clusters,
             colors = pal,
             size = 0.5) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = "UMAP_1"), yaxix = list(title = "UMAP_2"), zaxis = list(title = "UMAP_3")))

htmlwidgets::saveWidget(p, paste0(myfolder, "umap3d.html"))
```


## Cell number per sample per clusters

```{r}
table(data@meta.data[["orig.ident"]])
unique(data@meta.data[["orig.ident"]])

# Create list of data frame by splitting by orig.ident
sampleID_list <- unique(data@meta.data$orig.ident)
df_list <- list()

for (ID in sampleID_list) {
subsetID <- data@meta.data$orig.ident == ID
data_subsetID <- data[,subsetID]
df_list[[ID]] <- data_subsetID
}

# Create table of cell proportions 
df <-  data.frame(ID = 1:31)

for (ID in 1:length(df_list)) {
name_ID <- unique(df_list[[ID]]@meta.data[["orig.ident"]])
table_ID <- table(df_list[[ID]]@meta.data[["high_level_clusters_removed"]])

# write single sheet
df[[paste0(name_ID, ID)]] <- table_ID
write.csv2(df,paste0(myfolder, "sampleID/xcell_", "cell_by_cluster.csv"))

# write 1 sheet per sample ID
write.csv2(table(df_list[[ID]]@meta.data[["high_level_clusters_removed"]]),
           paste0(myfolder, "sampleID/xcell_", name_ID, "_cell_by_cluster.csv"))
}
```


## DEG subsets

#### Round 1: CM_21, EN_14, FB_20

```{r}
#keep only CM_21, EN_14, FB_20
round1_1 <- CM[, CM$clusters_subset == "21"]
round1_2 <- EN[, EN$clusters_subset == "14"]
round1_3 <- FB[, FB$clusters_subset == "20"]

round1 <-  merge(round1_1, y = list(round1_2, round1_3), add.cell.ids = c("1", "2", "3"))

round1$clusters_subset[round1$clusters_subset == "21"] <- "CM_21"
round1$clusters_subset[round1$clusters_subset == "14"] <- "EC_14"
round1$clusters_subset[round1$clusters_subset == "20"] <- "FB_20"

# Select a new samples size for each cluster, to get groups that are equally (or almost equally) large.
sample_size <- table(round1$clusters_subset)
sample_size[sample_size > 200] <- 200
sample_size


# Randomly sample the cells that will be included when calculating DGE (same number of cells as selected above).
# Samples without replacement, so each cell only can be included once.
DGE_cells <- lapply(names(sample_size), function(x){ 
  set.seed(1)
  sample(colnames(round1)[round1$clusters_subset == x], size = sample_size[x])
  })
DGE_cells <- unlist(DGE_cells)

# Select all data that relates to the sampled DGE cells.
DGE_DATA <- round1[, DGE_cells]

#Find differential expressed genes based on groups defined by "clusters_subset_split".
DGE_DATA <- SetIdent(DGE_DATA, value = "clusters_subset")

# The logfc threshold is set to 0.1 as compared to the default 0.25, which makes the detection of weaker signals possible (but it takes more computational power).
detable_round1 <- FindAllMarkers(DGE_DATA,
                          only.pos = TRUE,
                          max.cells.per.ident = 300,
                          logfc.threshold = .1,
                          assay = "RNA",
                          min.pct = 0.05)

# Only keep DEG that have a p-value below 0.05.
detable_round1 <- detable_round1[detable_round1$p_val < 0.05, ]

# Adding two extra columns giving the difference (and log difference) between pct1 and pct2.
# pct1 is the percentage of cells in the specific cluster that express this gene.
# pct2 is the percentage of cells in all other clusters that express this gene.
detable_round1$pct.diff <- detable_round1$pct.1 - detable_round1$pct.2
detable_round1$log.pct.diff <- log2((detable_round1$pct.1*99+1) / (detable_round1$pct.2*99+1))

# Save the detable as a csv file.
write.csv2(detable_round1, paste0(myfolder, "DEG_special/detable_round1.csv"))

# Pick the 60 genes with the lowest p value for each age group, then 40 highest based on pct.diff, then 20 highest based on log.pct.diff.
detable_round1 %>%
  group_by(cluster) %>%
  top_n(-60, p_val) %>%
  top_n(40, pct.diff) %>%
  top_n(20, log.pct.diff) ->
  top20

# Unclear what this does since there is no documentation for getcluster(). But my guess is that the genes get matched to one specific cluster somehow, and the factor is leveled based on cluster number.
ord <- factor(sapply(unique(as.character(top20$gene)), function(x){niceRplots::getcluster(DGE_DATA, x, "clusters_subset")}))


pdf(paste0(myfolder, "DEG_special/DGE_round1.pdf"), width = 15, height = length(ord)/6+1)
par(mfrow=c(1,1), mar=c(3,6,2,5))
DotPlot(DGE_DATA, features = unique(as.character(top20$gene))[order(as.numeric(as.character(ord)))]) +
  coord_flip() +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete(limits = rev) +
  scale_y_discrete() +
  #labs(x = "", y = "") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
dev.off()

rm(detable_round1, DGE_DATA, top20, DGE_cells, ord, sample_size, round1_1, round1_2, round1_3)
```


#### Round 2: HL_22, EC_22, FB_21, FB_15

```{r}
#keep only HL_22, EC_22, FB_21, FB_15
round2_1 <- data[, data$high_level_clusters_removed == "22"]
round2_1$clusters_subset <- round2_1$high_level_clusters
round2_1$clusters_subset[round2_1$clusters_subset == "22"] <- "HL_22"

round2_2 <- EN[, EN$clusters_subset == "22"]

round2_3 <- FB[, FB$clusters_subset == "21"]

round2_4 <- FB[, FB$clusters_subset == "15"]

round2 <-  merge(round2_1, y = list(round2_2, round2_3, round2_4), add.cell.ids = c("1", "2", "3", "4"))

round2$clusters_subset[round2$clusters_subset == "22"] <- "EC_22"
round2$clusters_subset[round2$clusters_subset == "21"] <- "FB_21"
round2$clusters_subset[round2$clusters_subset == "15"] <- "FB_15"


# Select a new samples size for each cluster, to get groups that are equally (or almost equally) large.
sample_size <- table(round2$clusters_subset)
sample_size[sample_size > 200] <- 200
sample_size


# Randomly sample the cells that will be included when calculating DGE (same number of cells as selected above).
# Samples without replacement, so each cell only can be included once.
DGE_cells <- lapply(names(sample_size), function(x){ 
  set.seed(1)
  sample(colnames(round2)[round2$clusters_subset == x], size = sample_size[x])
  })
DGE_cells <- unlist(DGE_cells)

# Select all data that relates to the sampled DGE cells.
DGE_DATA <- round2[, DGE_cells]

#Find differential expressed genes based on groups defined by "clusters_subset_split".
DGE_DATA <- SetIdent(DGE_DATA, value = "clusters_subset")

# The logfc threshold is set to 0.1 as compared to the default 0.25, which makes the detection of weaker signals possible (but it takes more computational power).
detable_round2 <- FindAllMarkers(DGE_DATA,
                          only.pos = TRUE,
                          max.cells.per.ident = 300,
                          logfc.threshold = .1,
                          assay = "RNA",
                          min.pct = 0.05)

# Only keep DEG that have a p-value below 0.05.
detable_round2 <- detable_round2[detable_round2$p_val < 0.05, ]

# Adding two extra columns giving the difference (and log difference) between pct1 and pct2.
# pct1 is the percentage of cells in the specific cluster that express this gene.
# pct2 is the percentage of cells in all other clusters that express this gene.
detable_round2$pct.diff <- detable_round2$pct.1 - detable_round2$pct.2
detable_round2$log.pct.diff <- log2((detable_round2$pct.1*99+1) / (detable_round2$pct.2*99+1))

# Save the detable as a csv file.
write.csv2(detable_round2, paste0(myfolder, "DEG_special/detable_round2.csv"))

# Pick the 60 genes with the lowest p value for each age group, then 40 highest based on pct.diff, then 20 highest based on log.pct.diff.
detable_round2 %>%
  group_by(cluster) %>%
  top_n(-60, p_val) %>%
  top_n(40, pct.diff) %>%
  top_n(20, log.pct.diff) ->
  top20

# Unclear what this does since there is no documentation for getcluster(). But my guess is that the genes get matched to one specific cluster somehow, and the factor is leveled based on cluster number.
ord <- factor(sapply(unique(as.character(top20$gene)), function(x){niceRplots::getcluster(DGE_DATA, x, "clusters_subset")}))


pdf(paste0(myfolder, "DEG_special/DGE_round2.pdf"), width = 15, height = length(ord)/6+1)
par(mfrow=c(1,1), mar=c(3,6,2,5))
DotPlot(DGE_DATA, features = unique(as.character(top20$gene))[order(as.numeric(as.character(ord)))]) +
  coord_flip() +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete(limits = rev) +
  scale_y_discrete() +
  #labs(x = "", y = "") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
dev.off()

rm(detable_round2, DGE_DATA, top20, DGE_cells, ord, sample_size, round2_1, round2_2, round2_3, round2_4)
```


#### Round 3: CM_21, EC_14, FB_20, HL_22, EC_22, FB_21, FB_15

```{r}
round3 <-  merge(round2, y = list(round1), add.cell.ids = c("1", "2"))

# Select a new samples size for each cluster, to get groups that are equally (or almost equally) large.
sample_size <- table(round3$clusters_subset)
sample_size[sample_size > 200] <- 200
sample_size


# Randomly sample the cells that will be included when calculating DGE (same number of cells as selected above).
# Samples without replacement, so each cell only can be included once.
DGE_cells <- lapply(names(sample_size), function(x){ 
  set.seed(1)
  sample(colnames(round3)[round3$clusters_subset == x], size = sample_size[x])
  })
DGE_cells <- unlist(DGE_cells)

# Select all data that relates to the sampled DGE cells.
DGE_DATA <- round3[, DGE_cells]

#Find differential expressed genes based on groups defined by "clusters_subset_split".
DGE_DATA <- SetIdent(DGE_DATA, value = "clusters_subset")

# The logfc threshold is set to 0.1 as compared to the default 0.25, which makes the detection of weaker signals possible (but it takes more computational power).
detable_round3 <- FindAllMarkers(DGE_DATA,
                          only.pos = TRUE,
                          max.cells.per.ident = 300,
                          logfc.threshold = .1,
                          assay = "RNA",
                          min.pct = 0.05)

# Only keep DEG that have a p-value below 0.05.
detable_round3 <- detable_round3[detable_round3$p_val < 0.05, ]

# Adding two extra columns giving the difference (and log difference) between pct1 and pct2.
# pct1 is the percentage of cells in the specific cluster that express this gene.
# pct2 is the percentage of cells in all other clusters that express this gene.
detable_round3$pct.diff <- detable_round3$pct.1 - detable_round3$pct.2
detable_round3$log.pct.diff <- log2((detable_round3$pct.1*99+1) / (detable_round3$pct.2*99+1))

# Save the detable as a csv file.
write.csv2(detable_round3, paste0(myfolder, "DEG_special/detable_round3.csv"))

# Pick the 60 genes with the lowest p value for each age group, then 40 highest based on pct.diff, then 20 highest based on log.pct.diff.
detable_round3 %>%
  group_by(cluster) %>%
  top_n(-60, p_val) %>%
  top_n(40, pct.diff) %>%
  top_n(20, log.pct.diff) ->
  top20

# Unclear what this does since there is no documentation for getcluster(). But my guess is that the genes get matched to one specific cluster somehow, and the factor is leveled based on cluster number.
ord <- factor(sapply(unique(as.character(top20$gene)), function(x){niceRplots::getcluster(DGE_DATA, x, "clusters_subset")}))


pdf(paste0(myfolder, "DEG_special/DGE_round3.pdf"), width = 15, height = length(ord)/6+1)
par(mfrow=c(1,1), mar=c(3,6,2,5))
DotPlot(DGE_DATA, features = unique(as.character(top20$gene))[order(as.numeric(as.character(ord)))]) +
  coord_flip() +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete(limits = rev) +
  scale_y_discrete() +
  #labs(x = "", y = "") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
dev.off()

rm(detable_round3, DGE_DATA, top20, DGE_cells, ord, sample_size)
```


At this point, the analysis continues on subsets of the data on other scripts.

================================================================================
================================================================================
================================================================================
================================================================================
================================================================================






