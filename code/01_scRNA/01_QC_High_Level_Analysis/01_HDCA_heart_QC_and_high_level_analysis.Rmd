---
title: "01_HDCA_heart_QC_and_high_level_analysis"
author: "Julia Foyer, Ludvig Larsson & RaphaÃ«l Mauron"
output: html_document
editor_options: 
  chunk_output_type: console
---

# HDCA heart QC and high level analysis

Here begins the analysis of the single-cell embryonic heart development. The script consists of the initial processing of the data, followed by filtering and analysis of the main High-Level clusters. Subsequently, numerous complementary analyses are conducted on the data generated by this script.

NOTE: The path to load the data and the path to save the figures should be changed at your convenience.

Environment: **Docker**


## Settings

### Set library path

```{r setup, include=FALSE}
.libPaths("/home/rstudio/project/renv/library/R-4.3/aarch64-unknown-linux-gnu/")
knitr::opts_chunk$set(echo = TRUE)
```


### Set environment variables

```{r}
# Set the directory 
myfolder <- "/home/rstudio/project/output/HDCA_heart_sc_analysis_docker/"
PATH_DATA <- "/home/rstudio/project/data/h5_files/"
file_list <- list.files(PATH_DATA, full.names = FALSE, pattern = ".h5")
```


### Load Libraries

```{r, message = FALSE}
library(Seurat)
library(Matrix)
library(future)
library(RcppHNSW)
library(igraph)
library(future.apply)
library(niceRplots)
library(DoubletFinder)
library(ggplot2)
library(ROCR)
library(KernSmooth)
library(dplyr)
library(patchwork)
library(harmony)
library(gprofiler2)
library(plotly)
```


### Load global functions

```{r}
source("/home/rstudio/project/code/global_functions.R")
```


### Set seed

```{r}
set.seed(1)
```


## Read files

### Create Seurat object from .h5 files

```{r}
plan(multicore, workers=7 )

# load the matrix, create a Seurat object and store it in a list for all datasets in parallel
data_list <- future_lapply( 
  file_list ,function(x) { 
    data <- Matrix::Matrix(rhdf5::h5read(paste0(PATH_DATA,x), name = "/shoji/Expression"), sparse = TRUE)
    colnames(data) <-  rhdf5::h5read(paste0(PATH_DATA,x), name = "/shoji/Cellid")
    rownames(data) <-  rhdf5::h5read(paste0(PATH_DATA,x), name = "/shoji/Gene")
    data <- CreateSeuratObject(counts = data)
    data$sampleID <- gsub(".h5", "", x)
    return(data)
    } ,future.seed = 1)

names(data_list) <- file_list
gc()
```


### Merge datasets

```{r}
plan(multicore, workers=7)

data <- merge(data_list[[1]], data_list[-1])
rm(data_list)
gc()
```


### Import metadata from loom files and metadata file

```{r}
temp <- future_lapply( 
  file_list ,function(x) { 
    temp <- rhdf5::h5read(paste0(PATH_DATA,x),name = "/shoji/DoubletFlag")
    temp2 <-  rhdf5::h5read(paste0(PATH_DATA,x),name = "/shoji/DoubletScore")
    temp3 <-  rhdf5::h5read(paste0(PATH_DATA,x),name = "/shoji/DropletClass")
    temp4 <- cbind(DoubletFlag = temp, DoubletScore = temp2, DropletClass = temp3)
    rownames(temp4) <-  rhdf5::h5read(paste0(PATH_DATA,x),name = "/shoji/Cellid")
    return(temp4)
    } ,future.seed = 1 )

# Apply the function rbind to all elements of the list temp to combine them by row.
temp <- do.call(rbind, temp)
# Add the temp dataframe to the Seurat metadata. Column bind (put the columns side by side)
data@meta.data <- cbind(data@meta.data, temp)

metadata <- read.delim("/home/rstudio/project/data/metadata/Result_1_210211_121011.tab",row.names = 2)
identities <- as.character(sub("Ten", 10, file_list))
metadata <- metadata[as.character(sub(".h5","",identities)),]
metadata$age
data@meta.data$age <- metadata[match(sub(":.*", "",colnames(data)), rownames(metadata)), "age"]

gc()
rm(file_list)
```


### Round ages to create age groups

```{r}
# Factor automatically adds Levels based on alphabetical order.
data$age_round_up <- factor(sprintf("%02d",ceiling(data$age)))
data$age_round_down <- factor(sprintf("%02d",floor(data$age)))
```


## QC

### Normalize data

```{r}
plan(sequential)
data <- NormalizeData(data)
gc()
```


### QC calculation

* Calculate percentage of ribosomal protein coding genes ^RP[LS]
* Calculate percentage of mitochondrial protein coding genes ^MT-
* Calculate percentage of hemoglobin genes ^HB[^ESP]|HBE1
* Calculate percentage of heat shock protein coding genes ^HSP

```{r}
plan(multicore, workers = 7)
data <- PercentageFeatureSet(data,pattern = "^RP[LS]", col.name = "percent_ribo")
data <- PercentageFeatureSet(data,pattern = "^MT-", col.name = "percent_mito")
data <- PercentageFeatureSet(data,pattern = "^HB[^ESP]|HBE1", col.name = "percent_hb")
data <- PercentageFeatureSet(data,pattern = "^HSP", col.name = "percent_hsp")
# Add a flag for potentially apoptotic cells
data$apoptotic_maybe <- data$percent_hsp > 2
gc()
```


### Cell cycle score calculation

Use `CellCycleScoring` from Seurat to estimate scores for G1, G2M and S phases.

```{r}
plan(sequential)

# For the results, never trust the "phase".
data <- CellCycleScoring(data, 
                          s.features = cc.genes.updated.2019$s.genes,
                          g2m.features = cc.genes.updated.2019$g2m.genes)
gc()
```


### Find Variable Features

```{r}
plan(sequential)
data <- FindVariableFeatures(data, nfeatures = 4000)
gc()
```


### Scale Data

Fits a linear regression for every gene against confounding variables to compute the residuals (corrected values), which are then centered (mean = 0) and scaled (STD = 1). The resulting matrix will be FULL and not sparse. This takes a lot of memory and can be deleted after computing PCA.

```{r}
plan(sequential)
data <- ScaleData(data)
gc()
```


### PCA

This is a stochastic (rather than deterministic) algorithm for calculating PCA. This function uses the irlba package, which makes it stochastic. For stochastic you can predifine how many PCs you want to compute, but for the deterministic approach (package prcomp) the minimal number of PCs will be the number of rows or columns of the original matrix (depending on which one is smaller), e.g. 3000 variable genes.

```{r}
plan(sequential)
data <- RunPCA(data, npcs = 50, verbose = TRUE, seed.use = 42)
gc()
```


### UMAP

```{r}
data <- RunUMAP(data, 
                dims = 1:50, 
                reduction = "pca",
                n.neighbors = 10,
                n.epochs = 200,
                reduction.key = "unfilt",
                reduction.name = "umap_unfilt",
                seed.use = 42)
gc()
```


### Graph construction

Use the `RcppHNSW` R package to create a nearest neighbor (nn) adjacency matrix.

```{r}
set.seed(1)
nn <- CreateNNAdjacencyMatrix(data, reduction = "pca", dims = 1:50, k = 20)
```


### Clustering

```{r}
# Cluster adjacency matrix
cl <- LouvainClustering(nn = nn, resolution = 1)
data$clusters_louvain_unfilt <- factor(cl)

gc()
```


## Export Seurat object unfiltered

Export the Seurat object containing the initial clusters, reduced dimensions, ... before filtering steps. 

```{r}
saveRDS(data, paste0(myfolder, "rds_objects/HDCA_heart_sc_unfiltered.rds"))
```

```{r}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_unfiltered.rds"))
```


## QC infos and Plotting of QC + some metafeatures

```{r}
data
```

#[1]  59480 107673


## Filtering

### Select cells to filter prior to running doublet finder

* Remove cells with a percentage of mitochondrial gene counts above 30%
* Remove cells with a percentage of ribosomal protein coding gene counts below 3% and a percentage of hemoglobin gene counts below 10% 
* Remove cells with less than 250 unique genes detected and a percentage of hemoglobin gene counts below 10% 

```{r, results='hide'}
cells_to_filter_out1 <- data@meta.data$percent_mito > 30
cells_to_filter_out2 <- data@meta.data$percent_ribo < 3 & data@meta.data$percent_hb < 10
cells_to_filter_out3 <- data@meta.data$nFeature_RNA < 250 & data@meta.data$percent_hb < 10
to_filter <- cells_to_filter_out1 | cells_to_filter_out2 | cells_to_filter_out3

rm(cells_to_filter_out1, cells_to_filter_out2, cells_to_filter_out3)
gc()
```


### Filter cells

Remove all cells fulfilling filter criteria.

```{r}
data <- data[, !to_filter]
```


### Doublet Finding

`FindDoublets` runs a doublet detection workflow for each dataset (sampleID) separately. The results are then merged to create a new Seurat object.

```{r}
data_list <- FindDoublets(data = data, myfolder = myfolder)
```


## Export Seurat objects (data_list) after doublets are detected

```{r}
saveRDS(data_list, paste0(myfolder, "rds_objects/HDCA_heart_sc_doubletfound.rds"))
```

```{r}
data_list <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_doubletfound.rds"))
```


## Merge data_list into data

```{r}
gc()
plan(sequential)
data <- merge(data_list[[1]], data_list[-1])
rm(data_list)
gc()
```


### Rerun normalization, variable feature detection, scaling, PCA, UMAP on the new formed/merged Seurat object

```{r}
set.seed(1)
gc()
plan(sequential)

data <- data %>%
  NormalizeData() %>%
  FindVariableFeatures(nfeatures = 4000)
gc()


data <- data %>%
  ScaleData() 
gc()


data <- data %>%
  RunPCA(npcs = 50, seed.use = 42) %>%
  RunUMAP(dims = 1:50, n.neighbors = 10, n.epochs = 200,
          n.threads = 7, reduction.key = "unfilt", reduction.name = "umap_df", seed.use = 42)

set.seed(1)
# Convert doublet classes to factor
data$DF.classifications <- factor(data$DF.classifications, levels = c("Singlet", "Doublet"))
gc()
```


## Export Seurat object (data) with doublet scores added to the object

```{r}
saveRDS(data, paste0(myfolder, "rds_objects/HDCA_heart_sc_doubletfound02.rds"))
```

```{r}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_doubletfound02.rds"))
```

# [1]  59480 101104

## Samples Quality: nCount & nFeature *after filtering and doublet found*

```{r}
#Violin plot
pdf(paste0(myfolder, "p_nFeature_RNA_after_filter.pdf"), width = 15, height = 15)
VlnPlot(data, features = "nFeature_RNA")
dev.off()

pdf(paste0(myfolder, "p_nCount_RNA_after_filter.pdf"), width = 15, height = 15)
VlnPlot(data, features = "nCount_RNA")
dev.off()
```


## Second filtering (RBC & doublets)

* Remove erythrocytes (RBCs) based on percentage of hemoglobin counts. These were not removed in the previous filter because they were used for the doublet detection. 
* Remove detected doublets.

```{r}
cells_to_filter_out1 <- data@meta.data$percent_hb > 10
cells_to_filter_out2 <- data@meta.data$DF.classifications == "Doublet"
to_filter <- cells_to_filter_out1 | cells_to_filter_out2
rm(cells_to_filter_out1, cells_to_filter_out2)
```


### Filter cells based on second filter criteria.

```{r}
data <- data[, !to_filter]
gc()
rm(to_filter)
```


## Dimensionality reduction

### Find variable genes

```{r}
set.seed(1)
plan(sequential)
data <- FindVariableFeatures(data, nfeatures = 4000)
gc()
```


## Export Seurat object after the 2 filtering steps

```{r, eval=FALSE}
saveRDS(object = data, 
        file = paste0(myfolder, "rds_objects/HDCA_heart_sc_scaledata_prefiltered_adjusted0.rds"))
```

```{r, include=FALSE}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_scaledata_prefiltered_adjusted0.rds"))
```


### Scale Data

Fits a linear regression for every gene against confounding variables to compute the residuals (corrected values), which are then centered (mean = 0) and scaled (STD = 1). The resulting matrix will be FULL and not sparse. This takes a lot of memory and can be deleted after computing PCA.

```{r}
set.seed(1)
plan(sequential)
data <- ScaleData(data, 
                  vars.to.regress = c("nCount_RNA", "nFeature_RNA", "percent_ribo", 
                                      "percent_mito", "percent_hb", "percent_hsp", 
                                      "S.Score", "G2M.Score"))
gc()
```


## Export Seurat object scaled after filtering steps

```{r, eval=FALSE}
saveRDS(object = data, file = paste0(myfolder, "rds_objects/HDCA_heart_sc_scaledata_prefiltered_adjusted.rds"))
```

```{r, include=FALSE}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_scaledata_prefiltered_adjusted.rds"))
```

# [1] 59480 76991

### PCA

This is a stochastic (rather than deterministic) algorithm for calculating PCA. This function uses the irlba package, which makes it stochastic. For stochastic you can predefine how many PCs you want to compute, but for the deterministic approach (package prcomp) the minimal number of PCs will be the number of rows or columns of the original matrix (depending on which one is smaller), e.g. 3000 variable genes.

```{r}
data <- RunPCA(data, npcs = 50, seed.use = 42)
gc()
```


## Integration

### Integration based on sampleID

Use harmony to integrate data across samples.

```{r}
# Integration based on dataset
set.seed(1)
data <- RunHarmony(data, dims.use = 1:50,
                   group.by.vars = c("sampleID"), 
                   reduction = "pca",
                   project.dim = FALSE,
                   reduction.save = "harmony_oi")
gc()
```


### UMAP computation

Use harmony reduced dimension of data as input for UMAP.

```{r}
data <- RunUMAP(data, 
                dims = 1:50, 
                reduction = "harmony_oi",
                n.neighbors = 10,
                metric = "cosine",
                n.epochs = 100,
                reduction.key = "oi_",
                reduction.name = "umap_oi",
                seed.use = 42)
```


## Clustering

```{r}
set.seed(1)
# Create adjacency matrix from harmony reduced dimension
nn <- CreateNNAdjacencyMatrix(data = data, reduction = "harmony_oi", dims = 1:50, k = 20)

# Cluster adjacency matrix
cl <- LouvainClustering(nn = nn, resolution = 1.8)

# add to metadata
data$clusters_louvain_oi <- factor(cl)

gc()
```

```{r}
rm(nn, cl)
```


### Visualize clusters

```{r}
pdf(paste0(myfolder, "clusters.pdf"), width = 15, height = 15)
DimPlot(data, reduction = "umap_oi", group.by = "clusters_louvain_oi", label = T, raster = F)
dev.off()
```


## Calculate differentially expressed genes (DEG) *before annotation*

### Remove mitochondrial and ribosomal protein coding genes

```{r}
data <- data[!grepl("^MT-", rownames(data)), ]
data <- data[!grepl("^RP[LS]", rownames(data)), ]
gc()
```

```{r}
# Select a new samples size for each cluster, to get groups that are equally (or almost equally) large.
sample_size <- table(data$clusters_louvain_oi)
sample_size[sample_size > 150] <- 150
sample_size

# Randomly sample the cells that will be included when calculating DGE (same number of cells as selected above).
# Samples without replacement, so each cell only can be included once.
DGE_cells <- lapply(names(sample_size), function(x){ 
  set.seed(1)
  sample(colnames(data)[data$clusters_louvain_oi == x], size = sample_size[x])
  })
DGE_cells <- unlist(DGE_cells)

# Select all data that relates to the sampled DGE cells.
DGE_DATA <- data[, DGE_cells]

#Find differentially expressed genes based on groups defined by "clusters_louvain_oi".
DGE_DATA <- SetIdent(DGE_DATA, value = "clusters_louvain_oi")

# The logfc threshold is set to 0.1 as compared to the default 0.25, which makes the detection of weaker signals possible (but it takes more computational power).
detable <- FindAllMarkers(DGE_DATA,
                          only.pos = TRUE,
                          max.cells.per.ident = 300,
                          logfc.threshold = .1,
                          assay = "RNA",
                          min.pct = 0.05)

# Only keep DEGs that have a p-value below 0.05.
detable <- detable[detable$p_val < 0.05, ]

# Adding two extra columns giving the difference (and log difference) between pct1 and pct2.
# pct1 is the percentage of cells in the specific cluster that express this gene.
# pct2 is the percentage of cells in all other clusters that express this gene.
detable$pct.diff <- detable$pct.1 - detable$pct.2
detable$log.pct.diff <- log2((detable$pct.1*99+1) / (detable$pct.2*99+1))

# Save the detable as a csv file.
write.csv2(detable, paste0(myfolder, "detable_rough_clusters.csv"))

rm(detable, DGE_DATA, DGE_cells, sample_size)
```


## Export Seurat object before adding the annotation

```{r}
saveRDS(data, paste0(myfolder, "rds_objects/HDCA_heart_sc_full_before_annotation.rds"))
```

```{r}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_full_before_annotation.rds"))
```


### Merge clusters 4 & 35

Based on the DEG, clusters 4 and 35 were merged as a unique cell type.

```{r}
df <- data.frame(matrix(ncol = 2, nrow = length(colnames(data))))
colnames(df) <- c("data_cluster", "clusters_comb")
df$data_cluster <- data@meta.data$clusters_louvain_oi

df$clusters_comb <- ifelse(is.na(df$clusters_comb), df$data_cluster, df$clusters_comb)
df$clusters_comb <- ifelse(df$clusters_comb == 4, "4_35", df$clusters_comb)
df$clusters_comb <- ifelse(df$clusters_comb == 35, "4_35", df$clusters_comb)

data$high_level_clusters <- factor(df$clusters_comb, levels = c(1, 2, 3, "4_35", 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, "18_1", "18_2", 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34))
```


### Subcluster (cluster 18)

Based on the DEG, cluster 18 was selected and umap clustering was made on it separately. The subsequent 2 clusters were added to the high level clusters. 

```{r}
cl18 <- data[, as.character(data$clusters_louvain_oi) == "18"] %>% 
  RunUMAP(dims = 1:50,
          reduction = "harmony_oi",
          n.neighbors = 30,
          n.epochs = 100,
          n.threads = 7,
          reduction.key = "subset",
          reduction.name = "umap_subset_cl18")

# Compute k nearest neighbours
nn <- CreateNNAdjacencyMatrix(data = cl18, reduction = "harmony_oi", k = 30, dims = 1:50)

# Create an undirected graph based on the neighbor matrix.
cl <- LouvainClustering(nn = nn, resolution = 0.25)
cl18$clusters_subset_cl18 <- factor(cl)

pdf(paste0(myfolder, "subset_high_cl18.pdf"), width = 10, height = 10)
DimPlot(cl18, reduction = "umap_subset_cl18", group.by = "clusters_subset_cl18", label = TRUE) + NoLegend()
dev.off()
```

```{r}
cl18 <- SetIdent(cl18, value = "clusters_subset_cl18")
de_markers_cl18 <- FindAllMarkers(cl18, only.pos = TRUE, logfc.threshold = 0.5) %>% 
  filter(p_val_adj < 0.01)

openxlsx::write.xlsx(de_markers_cl18 %>% filter(p_val_adj < 0.01),
                     file = paste0(myfolder, "detable_cardiomyocytes_cl18.xlsx"))

p <- DotPlot(cl18, features = de_markers_cl18 %>% group_by(cluster) %>% 
          slice_head(n = 10) %>% pull(gene) %>% unique()) +
  coord_flip() +  # This flips the plot vertically
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete(limits = rev) +
  labs(x = "Genes", y = "Cluster")  # Flipped labels

pdf(paste0(myfolder, "dotplot_de_genes_cl18.pdf"), width = 10, height = 7)
print(p)
dev.off()
```


### Add cl18 subclusters

```{r}
cl18_split <- cl18[[]] %>% 
  select(clusters_subset_cl18) %>% 
  rename(clusters_subset_split = clusters_subset_cl18)


new_ids <- data[[]] %>% select(high_level_clusters)
new_ids[, "clusters_subset_split"] <- cl18_split[colnames(data), "clusters_subset_split", drop = TRUE]

new_ids <- new_ids %>% 
  mutate_if(is.factor, as.character) %>% 
  mutate(clusters_subset_split = case_when(!is.na(clusters_subset_split) ~ paste0("18_", clusters_subset_split),
                                           TRUE ~ high_level_clusters))

# rename "high_level_clusters" with the clusters 18 split
data$high_level_clusters <- new_ids$clusters_subset_split

rm(cl18, cl18_split, new_ids, nn)
```


### Visualize clusters merged

```{r}
pdf(paste0(myfolder, "clusters_high_level_merged_and_split.pdf"), width = 15, height = 15)
DimPlot(data, reduction = "umap_oi", group.by = "high_level_clusters", label = T, raster = F) + labs(title = "High level clusters")
dev.off()
```


### Remove low quality and red blood cells clusters (6, 19, 27, 34)

```{r}
data$high_level_clusters_removed <- factor(data$high_level_clusters, levels = c(1, 2, 3, "4_35", 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, "18_1", "18_2", 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33))

pdf(paste0(myfolder, "clusters_removed_before_annotation.pdf"), width = 15, height = 15)
DimPlot(data[, as.character(data$high_level_clusters_removed) %in% levels(data$high_level_clusters_removed)], reduction = "umap_oi", group.by = "high_level_clusters_removed", label = TRUE)
dev.off()

rm(df)
gc()
```


## Export Seurat object with final high level clusters before annotation

```{r}
saveRDS(data, paste0(myfolder, "rds_objects/HDCA_heart_sc_full_before_annotation02.rds"))
```

```{r}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_full_before_annotation02.rds"))
```


## Add the annotation

The annotation was imported from an external .csv file. The annotation is added as a new metadata row `cell.types` by matching the cluster numbers.

```{r}
annotation <- read.csv2("/home/rstudio/project/data/metadata/hl_annotation_2023-12-21.csv", header = 1, sep = ";")
cells_clusters <- setNames(annotation$cell_type, nm = annotation$cluster)
data$cell.types <- cells_clusters[as.character(data$high_level_clusters)]
rm(annotation, cells_clusters)
gc()
```


## *After annotation*

### Plot UMAP with annotations

```{r}
pdf(paste0(myfolder, "annotation.pdf"), width = 20, height = 15)
DimPlot(data[, as.character(data$high_level_clusters_removed) %in% levels(data$high_level_clusters_removed)], reduction = "umap_oi", group.by = "cell.types", label = TRUE)
dev.off()
gc()
```


### Add additional age groups to the metadata

```{r}
df <- data.frame(age = c(5.5, 6, 7, 8, 8.5, 9, 10, 11.5, 12, 13.25, 14), age_group = c("5-6", "5-6", "7-8", "7-8", "7-8", "9-11", "9-11", "9-11", "12-14", "12-14", "12-14"))
age_to_age_group <- setNames(df$age_group, nm = df$age)
data$age_groups <- factor(age_to_age_group[as.character(data$age)], levels = c("5-6", "7-8", "9-11", "12-14"))
rm(df)
gc()
```


## Export Seurat object (final High Level Seurat object)

```{r}
saveRDS(data, paste0(myfolder, "rds_objects/HDCA_heart_sc_full_extended.rds"))
```

```{r}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_full_extended.rds"))
```


## Calculate differentially expressed genes (DEG) after annotation

```{r}
# Select a new samples size for each cluster, to get groups that are equally (or almost equally) large.
sample_size <- table(data$high_level_clusters_removed)
sample_size[sample_size > 150] <- 150
sample_size

# Randomly sample the cells that will be included when calculating DGE (same number of cells as selected above).
# Samples without replacement, so each cell only can be included once.
DGE_cells <- lapply(names(sample_size), function(x){ 
  set.seed(1)
  sample(colnames(data)[data$high_level_clusters_removed == x], size = sample_size[x])
  })
DGE_cells <- unlist(DGE_cells)

# Select all data that relates to the sampled DGE cells.
DGE_DATA <- data[, DGE_cells]

#Find differentially expressed genes based on groups defined by "high_level_clusters_removed".
DGE_DATA <- SetIdent(DGE_DATA, value = "high_level_clusters_removed")

# The logfc threshold is set to 0.1 as compared to the default 0.25, which makes the detection of weaker signals possible (but it takes more computational power).
detable <- FindAllMarkers(DGE_DATA,
                          only.pos = TRUE,
                          max.cells.per.ident = 300,
                          logfc.threshold = .1,
                          assay = "RNA",
                          min.pct = 0.05)

# Only keep DEGs that have a p-value below 0.05.
detable <- detable[detable$p_val < 0.05, ]

# Adding two extra columns giving the difference (and log difference) between pct1 and pct2.
# pct1 is the percentage of cells in the specific cluster that express this gene.
# pct2 is the percentage of cells in all other clusters that express this gene.
detable$pct.diff <- detable$pct.1 - detable$pct.2
detable$log.pct.diff <- log2((detable$pct.1*99+1) / (detable$pct.2*99+1))

# Save the detable as a csv file.
write.csv2(detable, paste0(myfolder, "detable_rough_clusters_after_ann.csv"))

rm(detable, DGE_DATA, DGE_cells, sample_size)
```


## Age groups

```{r}
data <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_full_extended.rds"))
```


### Create the age groups

5-6 weeks
7-8 weeks
9-11 weeks
12-14 weeks

```{r}
age1 <- data[,data$age <= 6]
age2 <- data[,data$age == 7 | data$age == 8 | data$age == 8.5]
age3 <- data[,data$age == 9 | data$age == 10 | data$age == 11.5]
age4 <- data[,data$age >= 12]
```


#### Check cell group (age) with the fewest cells

```{r}
a1 <- sum(table(age1$sampleID))
a2 <- sum(table(age2$sampleID))
a3 <- sum(table(age3$sampleID))
a4 <- sum(table(age4$sampleID))
min_cell <- min(a1, a2, a3, a4)
min_cell
rm(a1, a2, a3, a4)
```


### Select random subsets of the same size

To 8742 cells (same size as the smallest age group, i.e., age3).

```{r}
set.seed(1) ; age1 <- age1[, sample(colnames(age1), size = min_cell)]
set.seed(1) ; age2 <- age2[, sample(colnames(age2), size = min_cell)]
set.seed(1) ; age3 <- age3[, sample(colnames(age3), size = min_cell)]
set.seed(1) ; age4 <- age4[, sample(colnames(age4), size = min_cell)]

ages <- c(age1, age2, age3, age4)

rm(age1, age2, age3, age4)
gc()
```


## Export Seurat object

```{r}
saveRDS(ages, paste0(myfolder, "rds_objects/HDCA_heart_sc_age_groups.rds"))
```

```{r}
ages <- readRDS(paste0(myfolder, "rds_objects/HDCA_heart_sc_age_groups.rds"))
```


### Temporal evolution of High Level UMAP

```{r}
pdf(file = paste0(myfolder, "Clusters_age_5_to_6_weeks_full_size.pdf"), width = 15, height = 15, bg = "transparent")
DimPlot(ages[[1]][, as.character(ages[[1]]$high_level_clusters_removed) %in% levels(ages[[1]]$high_level_clusters_removed)], reduction = "umap_oi", group.by = "cell.types", raster = F, pt.size = 1) + NoLegend()
dev.off()

pdf(file = paste0(myfolder, "Clusters_age_7_to_8_weeks_full_size.pdf"), width = 15, height = 15, bg = "transparent")
DimPlot(ages[[2]][, as.character(ages[[2]]$high_level_clusters_removed) %in% levels(ages[[2]]$high_level_clusters_removed)], reduction = "umap_oi", group.by = "cell.types", raster = F, pt.size = 1) + NoLegend()
dev.off()

pdf(file = paste0(myfolder, "Clusters_age_9_to_11_weeks_full_size.pdf"), width = 15, height = 15, bg = "transparent")
DimPlot(ages[[3]][, as.character(ages[[3]]$high_level_clusters_removed) %in% levels(ages[[3]]$high_level_clusters_removed)], reduction = "umap_oi", group.by = "cell.types", raster = F, pt.size = 1) + NoLegend()
dev.off()

pdf(file = paste0(myfolder, "Clusters_age_12_to_14_weeks_full_size.pdf"), width = 15, height = 15, bg = "transparent")
DimPlot(ages[[4]][, as.character(ages[[4]]$high_level_clusters_removed) %in% levels(ages[[4]]$high_level_clusters_removed)], reduction = "umap_oi", group.by = "cell.types", raster = F, pt.size = 1) + NoLegend()
dev.off()
```


### Cell type proportion by age group in entire data

```{r}
age1 <- data[,data$age <= 6]
age2 <- data[,data$age == 7 | data$age == 8 | data$age == 8.5]
age3 <- data[,data$age == 9 | data$age == 10 | data$age == 11.5]
age4 <- data[,data$age >= 12]

data_age <- c(age1, age2, age3, age4)
rm(age1, age2, age3, age4)


# create df by age grouping the number of cell per cluster
cell_by_cluster_entire_1 <- as.data.frame(table(data_age[[1]]@meta.data[["cell.types"]]))
cell_by_cluster_entire_2 <- as.data.frame(table(data_age[[2]]@meta.data[["cell.types"]]))
cell_by_cluster_entire_3 <- as.data.frame(table(data_age[[3]]@meta.data[["cell.types"]]))
cell_by_cluster_entire_4 <- as.data.frame(table(data_age[[4]]@meta.data[["cell.types"]]))

# add the proportion of each cell type
cell_by_cluster_entire_1$proportion <- cell_by_cluster_entire_1$Freq/sum(cell_by_cluster_entire_1$Freq)
cell_by_cluster_entire_2$proportion <- cell_by_cluster_entire_2$Freq/sum(cell_by_cluster_entire_2$Freq)
cell_by_cluster_entire_3$proportion <- cell_by_cluster_entire_3$Freq/sum(cell_by_cluster_entire_3$Freq)
cell_by_cluster_entire_4$proportion <- cell_by_cluster_entire_4$Freq/sum(cell_by_cluster_entire_4$Freq)

# export the df as .csv
write.csv2(cell_by_cluster_entire_1, paste0(myfolder, "cell_by_cluster_entire_1.csv"))
write.csv2(cell_by_cluster_entire_2, paste0(myfolder, "cell_by_cluster_entire_2.csv"))
write.csv2(cell_by_cluster_entire_3, paste0(myfolder, "cell_by_cluster_entire_3.csv"))
write.csv2(cell_by_cluster_entire_4, paste0(myfolder, "cell_by_cluster_entire_4.csv"))
```

```{r}
rm(cell_by_cluster_entire_1, cell_by_cluster_entire_2, cell_by_cluster_entire_3, cell_by_cluster_entire_4, data_age, ages)
gc()
```


## DotPlots

### High Level dotplot from selected markers

```{r}
# specific list of marker to project the dotplot on
my_markers <- c("MYH7", "MYH6", "MYBPC3", "TNNI1", "MYOZ2", "FABP3", "TMSB10", "S100A11", "GNG11", "FABP4", "VWF", "CDH5", "PECAM1", "LYVE1", "NPR3", "BMPER", "POSTN", "APCDD1", "TWIST1", "DDR2", "TCF21", "COL1A1", "MYH11", "ENPEP", "ITLN1", "PCSK1N", "MPZ", "C1QC", "JCHAIN", "CD3E", "KLRB1")

# remove undesired cells
cells_to_remove <- data$cell.types == "HL_excl_1" | 
                   data$cell.types == "HL_excl_2" | 
                   data$cell.types == "HL_excl_3" | 
                   data$cell.types == "HL_excl_4"

data_HL <- data[,!cells_to_remove]
rm(cells_to_remove)

# reorder the cell types desired
data_HL$high_level_clusters_removed <- factor(data_HL$cell.types, 
                                              levels = c("Mat_vCM",
                                                         "Mat_aCM",
                                                         "MetAct_vCM_1",
                                                         "MetAct_vCM_2",
                                                         "MetAct_aCM",
                                                         "Prol_CM",
                                                         "Immat_CM",
                                                         "TMSB10high_C_1",
                                                         "TMSB10high_C_2",
                                                         "MacroVasc_EC",
                                                         "MicroVasc_EC",
                                                         "PDE4Chigh_EC",
                                                         "LEC",
                                                         "Endoc_EC",
                                                         "EndocCush_EC",
                                                         "Valve_MC",
                                                         "PDE4Chigh_FB",
                                                         "Int_FB",
                                                         "Peric_MC",
                                                         "OFT_FB",
                                                         "EPDC",
                                                         "AnnFibr_FB",
                                                         "Prol_FB",
                                                         "OFT_SMC",
                                                         "CA_SMC",
                                                         "PC",
                                                         "EpC",
                                                         "NB-N",
                                                         "SCP-GC",
                                                         "MyC",
                                                         "LyC"))

data_HL <- SetIdent(data_HL, value = "high_level_clusters_removed")

p <- DotPlot(data_HL, features = my_markers) +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete() +
  scale_y_discrete(limits = rev) +
  labs(x = "", y = "") + 
  theme(axis.text.x = element_text(angle = 30, hjust = 1, size = 8))

pdf(paste0(myfolder, "HL_dotplot_DEG.pdf"), width = 13, height = 11)
print(p)
dev.off()

rm(p)
gc()
```


### Enrichment of ST cluster markers in HL single-cell clusters

```{r}
# specific list of marker to project the dotplot on
my_markers <- c("MT3", "HEY2", "NREP", "CKM", "FHL2", "MB", "LGALS3", "IRX3", "MASP1", "PPP1R12B", "ANGPT1", "BMP10", "DKK3", "PITX2", "ADAMTS8", "COL2A1", "ACTA1", "NPPB", "PGK1")


p <- DotPlot(data_HL, features = my_markers) +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete() +
  scale_y_discrete(limits = rev) +
  labs(x = "", y = "") + 
  theme(axis.text.x = element_text(angle = 30, hjust = 1, size = 8))

pdf(paste0(myfolder, "HL_dotplot_DEG_fig2.pdf"), width = 13, height = 11)
print(p)
dev.off()

rm(p)
gc()
```


#### CM from High Level dotplot from selected markers

```{r}
data_CM <- data[, data$high_level_clusters_removed == "4_35" |
                  data$high_level_clusters_removed == "5"    |
                  data$high_level_clusters_removed ==  "7"   |
                  data$high_level_clusters_removed == "9"    |
                  data$high_level_clusters_removed ==  "11"  |
                  data$high_level_clusters_removed == "17"   |
                  data$high_level_clusters_removed == "18_2" ]

# specific list of marker to project the dotplot on
my_markers <- c("CACNA1C", "CACNB2", "RYR2", "ATP2A2", "SLC8A1", "JPH2", "NEXN", "PPARGC1A", "ESRRG", "OPA1", "HK1", "HK2", "PKM", "ALDOA", "ENO1", "NDUFA1", "NDUFB4", "UQCRH", "UQCRB", "COX7C", "COX5A", "ATP5F1A", "ATP5MD")

# reorder the cell types desired
data_CM$cell.types <- factor(data_CM$cell.types,
                             levels = c("Mat_vCM", 
                                        "Mat_aCM", 
                                        "MetAct_vCM_1", 
                                        "MetAct_vCM_2", 
                                        "MetAct_aCM", 
                                        "Prol_CM", 
                                        "Immat_CM"))

#data_CM <- SetIdent(data_CM, value = "high_level_clusters_removed")
data_CM <- SetIdent(data_CM, value = "cell.types")


pdf(paste0(myfolder, "cardiomyocytes/dotplot_markers_high_level_CM_annot.pdf"), width = 7, height = 10)
par(mfrow=c(1,1), mar=c(3,6,2,5))
DotPlot(data_CM, features = my_markers) +
  coord_flip() +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, vjust = 0.5)) +
  scale_color_gradientn(colours = RColorBrewer::brewer.pal(n = 11, name = "RdBu") %>% rev()) +
  scale_x_discrete(limits = rev) +
  scale_y_discrete() +
  #labs(x = "", y = "") +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5))
dev.off()

rm(p)
gc()
```


At this point, the analysis continues on subsets of the data on other scripts.

================================================================================
================================================================================
================================================================================
================================================================================
================================================================================






